---
title: Serialization
description: Cairo serialization for calldata and storage.
---

Serialize TypeScript values to Cairo calldata format and deserialize results back.

## Quick Start

```typescript
import { serializeU256, deserializeU256, serializeArray } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

// Serialize u256 to [low, high] felts
const [low, high] = serializeU256(1000000000000000000n);

// Deserialize back
const value = deserializeU256([low, high]);

// Serialize array with length prefix
const felts = [Felt252(1n), Felt252(2n), Felt252(3n)];
const serialized = serializeArray(felts);
// [3n, 1n, 2n, 3n]
```

## When to Use Serde

| Scenario | Approach |
|----------|----------|
| Contract calls | Use `encodeCalldata` from `kundera/abi` |
| Manual calldata | Use serde functions directly |
| Custom encoding | Use serde functions directly |
| Parsing raw results | Use serde functions directly |

<Tip>
For most use cases, the ABI module handles serialization automatically. Use serde when building custom encoding logic or working with raw calldata.
</Tip>

## u256 Serialization

Cairo's u256 is split into two 128-bit felt values: `low` and `high`.

```typescript
import { serializeU256, deserializeU256 } from 'kundera/serde';

// Small values: high = 0
const amount = 1000000000000000000n; // 1e18
const [low, high] = serializeU256(amount);
// low = 1000000000000000000n, high = 0n

// Large values use both parts
const large = (1n << 200n) + 42n;
const [low2, high2] = serializeU256(large);
// low2 = 42n, high2 = 2^72

// Reconstruct
const original = deserializeU256([low2, high2]);
// original === large
```

### Manual u256 Calldata

```typescript
import { serializeU256 } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

// Build ERC20 transfer calldata manually
const recipient = Felt252('0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7');
const [amountLow, amountHigh] = serializeU256(1000000000000000000n);

const calldata = [recipient, amountLow, amountHigh];
```

## Array Serialization

Cairo arrays are serialized with a length prefix.

```typescript
import { serializeArray, deserializeArray } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

// Serialize: adds length prefix
const values = [Felt252(1n), Felt252(2n), Felt252(3n)];
const serialized = serializeArray(values);
// [3n, 1n, 2n, 3n]

// Deserialize: reads length, extracts elements
const data = [3n, 1n, 2n, 3n, 999n]; // Array + extra data
const { array, nextOffset } = deserializeArray(data, 0);
// array = [1n, 2n, 3n]
// nextOffset = 4 (points to 999n)
```

### Array of u256

```typescript
import { serializeU256 } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

// Serialize array of u256 values
const amounts = [100n, 200n, 300n];

// Each u256 becomes [low, high]
const serializedAmounts = amounts.flatMap(a => serializeU256(a));

// Wrap with array length
const calldata = [
  Felt252(amounts.length), // 3
  ...serializedAmounts,     // [low1, high1, low2, high2, low3, high3]
];
```

## ByteArray Serialization

For arbitrary bytes, use Cairo's ByteArray format.

```typescript
import { serializeByteArray } from 'kundera/serde';

// Encode text
const text = new TextEncoder().encode('Hello, Starknet!');
const serialized = serializeByteArray(text);
```

ByteArray format:
- `num_full_words`: Count of 31-byte chunks
- `...chunks`: Full 31-byte words as felts
- `pending_word`: Remaining bytes (< 31)
- `pending_word_len`: Length of pending word

### Long Strings

```typescript
import { serializeByteArray } from 'kundera/serde';

// Long string (> 31 bytes)
const longText = 'This is a much longer string that exceeds thirty-one bytes';
const bytes = new TextEncoder().encode(longText);
const serialized = serializeByteArray(bytes);

// serialized = [
//   1n,           // num_full_words
//   <31-byte chunk as felt>,
//   <pending bytes as felt>,
//   27n           // pending_word_len
// ]
```

## Using the CairoSerde Namespace

All functions are also available under a namespace:

```typescript
import { CairoSerde } from 'kundera/serde';

const [low, high] = CairoSerde.serializeU256(1000n);
const value = CairoSerde.deserializeU256([low, high]);
const serialized = CairoSerde.serializeArray(felts);
```

## Practical Examples

### Multicall Calldata

```typescript
import { serializeArray, serializeU256 } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

// Build multicall calldata for account.execute
function buildMulticallData(calls: Array<{
  to: string;
  selector: string;
  calldata: bigint[];
}>) {
  const result: bigint[] = [];

  // Number of calls
  result.push(BigInt(calls.length));

  for (const call of calls) {
    result.push(BigInt(call.to));
    result.push(BigInt(call.selector));

    // Calldata with length prefix
    result.push(BigInt(call.calldata.length));
    result.push(...call.calldata);
  }

  return result.map(v => Felt252(v));
}
```

### Parse Storage Result

```typescript
import { deserializeU256, deserializeArray } from 'kundera/serde';

// Raw storage result: [array_len, ...items, u256_low, u256_high]
const rawResult = [2n, 100n, 200n, 1000000n, 0n];

// Parse array (items 0-2)
const { array: items, nextOffset } = deserializeArray(rawResult, 0);
// items = [100n, 200n], nextOffset = 3

// Parse u256 (items 3-4)
const balance = deserializeU256([rawResult[3], rawResult[4]]);
// balance = 1000000n
```

### Custom Struct Serialization

```typescript
import { serializeU256 } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

interface Order {
  maker: string;
  taker: string;
  amount: bigint;
  price: bigint;
  expiry: bigint;
}

function serializeOrder(order: Order): bigint[] {
  const [amountLow, amountHigh] = serializeU256(order.amount);
  const [priceLow, priceHigh] = serializeU256(order.price);

  return [
    BigInt(order.maker),
    BigInt(order.taker),
    amountLow,
    amountHigh,
    priceLow,
    priceHigh,
    order.expiry,
  ];
}
```

## Comparison with ABI Encoding

```typescript
import { encodeCalldata } from 'kundera/abi';
import { serializeU256 } from 'kundera/serde';
import { Felt252 } from 'kundera/primitives';

// Using ABI (recommended for contract calls)
const { result: calldata1 } = encodeCalldata(abi, 'transfer', {
  recipient: '0x123...',
  amount: { low: 1000n, high: 0n },
});

// Using serde directly (for custom encoding)
const recipient = Felt252('0x123...');
const [low, high] = serializeU256(1000n);
const calldata2 = [recipient, low, high];

// Both produce equivalent calldata
```

<Warning>
When using serde directly, ensure your serialization matches the Cairo contract's expected format exactly. Incorrect serialization will cause transaction failures.
</Warning>

## Related

<CardGroup cols={2}>
  <Card title="Serde API" icon="code" href="/api/serde">
    Complete serde API reference.
  </Card>
  <Card title="ABI Encoding" icon="brackets-curly" href="/guides/abi/encode-decode">
    High-level calldata encoding.
  </Card>
  <Card title="Cairo Types" icon="cube" href="/concepts/cairo-types">
    Understanding Cairo type encoding.
  </Card>
</CardGroup>
