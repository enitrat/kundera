---
title: TypeScript to Effect Migration
description: Upgrade from Kundera TS to Kundera Effect
---

# Migrating from Kundera TS to Kundera Effect

Already using `@kundera-sn/kundera-ts`? This guide shows you how to upgrade to Effect for better error handling and composability.

## Why Migrate?

<AccordionGroup>
  <Accordion title="Type-Safe Error Handling">
    Effect tracks all possible errors at the type level:

    **Before (TypeScript):**
    ```typescript
    try {
      const result = await provider.getBlockNumber()
      return result
    } catch (error) {
      // What kind of error? Unknown!
      console.error(error)
    }
    ```

    **After (Effect):**
    ```typescript
    const program = ProviderService.getBlockNumber().pipe(
      Effect.catchTags({
        NetworkError: (error) => /* handle network errors */,
        TimeoutError: (error) => /* handle timeouts */,
      })
    )
    // Type system knows exactly what errors can occur
    ```
  </Accordion>

  <Accordion title="Composability">
    Chain operations without manual error propagation:

    **Before (TypeScript):**
    ```typescript
    try {
      const block = await provider.getBlock("latest")
      const txs = block.transactions
      const firstTx = await provider.getTransaction(txs[0])
      return firstTx
    } catch (error) {
      console.error(error)
      throw error
    }
    ```

    **After (Effect):**
    ```typescript
    const program = Effect.gen(function* () {
      const provider = yield* ProviderService
      const block = yield* provider.getBlock("latest")
      const firstTx = yield* provider.getTransaction(block.transactions[0])
      return firstTx
    })
    // Errors automatically propagate
    ```
  </Accordion>

  <Accordion title="Dependency Injection">
    Test with mock services easily:

    **Before (TypeScript):**
    ```typescript
    // Hard to mock
    const provider = new HttpProvider({ url: "..." })
    ```

    **After (Effect):**
    ```typescript
    // Easy to swap implementations
    const testLayer = ProviderService.test({ blockNumber: 123n })
    Effect.provide(program, testLayer)
    ```
  </Accordion>
</AccordionGroup>

## Step-by-Step Migration

### 1. Install Effect

```bash
npm install @kundera-sn/kundera-effect effect
```

### 2. Replace Provider

**Before:**
```typescript
import { HttpProvider } from "@kundera-sn/kundera-ts/provider"

const provider = new HttpProvider({ url: "..." })
const blockNumber = await provider.getBlockNumber()
```

**After:**
```typescript
import { ProviderService } from "@kundera-sn/kundera-effect/services"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const provider = yield* ProviderService
  const blockNumber = yield* provider.getBlockNumber()
  return blockNumber
})

const result = await Effect.runPromise(
  program.pipe(
    Effect.provide(ProviderService.layer({ url: "..." }))
  )
)
```

### 3. Replace Contract Interactions

**Before:**
```typescript
const balance = await provider.callContract({
  contractAddress: address,
  entrypoint: "balanceOf",
  calldata: [owner]
})
```

**After:**
```typescript
const program = Effect.gen(function* () {
  const contract = yield* ContractService

  const balance = yield* contract.read({
    address: address,
    entrypoint: "balanceOf",
    calldata: [owner]
  })

  return balance
})
```

### 4. Handle Errors Explicitly

**Before:**
```typescript
try {
  const result = await someOperation()
  return result
} catch (error) {
  console.error(error)
  return defaultValue
}
```

**After:**
```typescript
const program = someOperation().pipe(
  Effect.catchAll(error =>
    Effect.logError(`Error: ${error._tag}`).pipe(
      Effect.as(defaultValue)
    )
  )
)
```

## Gradual Migration

You don't have to migrate everything at once. Use both packages side-by-side:

```typescript
import { Felt252 } from "@kundera-sn/kundera-ts"
import { ProviderService } from "@kundera-sn/kundera-effect/services"
import { Effect } from "effect"

// Use TS primitives with Effect services
const program = Effect.gen(function* () {
  const provider = yield* ProviderService

  const felt = Felt252("0x123")
  const blockNumber = yield* provider.getBlockNumber()

  return { felt, blockNumber }
})
```

## Common Patterns

### Multiple Operations

**Before:**
```typescript
const block = await provider.getBlock("latest")
const txCount = block.transactions.length
const firstTx = await provider.getTransaction(block.transactions[0])
```

**After:**
```typescript
const program = Effect.gen(function* () {
  const provider = yield* ProviderService

  const block = yield* provider.getBlock("latest")
  const txCount = block.transactions.length
  const firstTx = yield* provider.getTransaction(block.transactions[0])

  return { block, txCount, firstTx }
})
```

### Conditional Logic

**Before:**
```typescript
const balance = await provider.callContract(...)
if (balance > threshold) {
  return await transfer(...)
} else {
  throw new Error("Insufficient balance")
}
```

**After:**
```typescript
const program = Effect.gen(function* () {
  const contract = yield* ContractService

  const balance = yield* contract.read(...)

  if (balance > threshold) {
    return yield* transfer(...)
  } else {
    return yield* Effect.fail(new InsufficientBalanceError())
  }
})
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Effect Guide" icon="book" href="/getting-started/effect-intro">
    Learn Effect basics
  </Card>

  <Card title="Services" icon="server" href="/effect/services/provider">
    Explore Effect services
  </Card>

  <Card title="Error Handling" icon="shield" href="/effect/guides/error-handling">
    Handle errors in Effect
  </Card>

  <Card title="Testing" icon="flask" href="/effect/guides/testing">
    Test Effect programs
  </Card>
</CardGroup>
