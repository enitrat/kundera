---
title: "index"
description: Auto-generated API documentation
---

[**@kundera-sn/kundera-ts**](index.mdx)

***

[@kundera-sn/kundera-ts](index.mdx) / index

# index

Kundera - Starknet Primitives Library

A high-performance library for Starknet types and cryptography.
Architecture: TypeScript API â†’ Rust FFI (starknet-crypto)

## Interfaces

### ByteArrayData

Defined in: [primitives/ByteArray/types.ts:16](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/types.ts#L16)

ByteArray - Variable-length byte sequence

Matches Cairo's ByteArray: an array of 31-byte words plus a pending partial word.
Used for strings and arbitrary byte data in Starknet.

Structure:
- data: Array of full 31-byte words (as Felt252)
- pendingWord: Partial word with < 31 bytes (as Felt252)
- pendingWordLen: Number of bytes in pendingWord (0-30)

#### Properties

##### data

> `readonly` **data**: readonly `bigint`[]

Defined in: [primitives/ByteArray/types.ts:18](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/types.ts#L18)

Full 31-byte words, each stored as bigint

##### pendingWord

> `readonly` **pendingWord**: `bigint`

Defined in: [primitives/ByteArray/types.ts:20](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/types.ts#L20)

Partial word (< 31 bytes) as bigint

##### pendingWordLen

> `readonly` **pendingWordLen**: `number`

Defined in: [primitives/ByteArray/types.ts:22](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/types.ts#L22)

Number of bytes in pendingWord (0-30)

***

### FeltMethods

Defined in: [primitives/Felt252/types.ts:5](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L5)

#### Methods

##### equals()

> **equals**(`other`): `boolean`

Defined in: [primitives/Felt252/types.ts:10](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L10)

###### Parameters

###### other

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### isValid()

> **isValid**(): `boolean`

Defined in: [primitives/Felt252/types.ts:8](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L8)

###### Returns

`boolean`

##### isZero()

> **isZero**(): `boolean`

Defined in: [primitives/Felt252/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L9)

###### Returns

`boolean`

##### toBigInt()

> **toBigInt**(): `bigint`

Defined in: [primitives/Felt252/types.ts:7](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L7)

###### Returns

`bigint`

##### toHex()

> **toHex**(): `string`

Defined in: [primitives/Felt252/types.ts:6](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L6)

###### Returns

`string`

***

### Signature

Defined in: [crypto/ECDSA/types.ts:6](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/types.ts#L6)

STARK curve ECDSA signature

#### Properties

##### r

> `readonly` **r**: [`Felt252Type`](#felt252type)

Defined in: [crypto/ECDSA/types.ts:7](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/types.ts#L7)

##### s

> `readonly` **s**: [`Felt252Type`](#felt252type)

Defined in: [crypto/ECDSA/types.ts:8](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/types.ts#L8)

## Type Aliases

### ByteArrayInput

> **ByteArrayInput** = [`ByteArrayType`](#bytearraytype) \| `Uint8Array` \| `string`

Defined in: [primitives/ByteArray/types.ts:30](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/types.ts#L30)

Input types that can be converted to ByteArray

***

### ByteArrayType

> **ByteArrayType** = `Brand`\<[`ByteArrayData`](#bytearraydata), `"ByteArray"`\>

Defined in: [primitives/ByteArray/types.ts:25](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/types.ts#L25)

***

### ClassHashType

> **ClassHashType** = `Brand`\<`Uint8Array`, `"ClassHash"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/ClassHash/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ClassHash/types.ts#L9)

ClassHash - Contract class identifier

***

### ContractAddressType

> **ContractAddressType** = `Brand`\<`Uint8Array`, `"ContractAddress"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/ContractAddress/types.ts:10](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ContractAddress/types.ts#L10)

ContractAddress - Starknet contract address
Must be < 2^251

***

### EthAddressType

> **EthAddressType** = `Brand`\<`Uint8Array`, `"EthAddress"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/EthAddress/types.ts:10](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/EthAddress/types.ts#L10)

EthAddress - L1 Ethereum address used in L1-L2 messaging
Must be < 2^160

***

### Felt252Input

> **Felt252Input** = [`Felt252Type`](#felt252type) \| `Uint8Array` \| `string` \| `bigint` \| `number`

Defined in: [primitives/Felt252/types.ts:24](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L24)

Input types that can be converted to Felt252

***

### Felt252Type

> **Felt252Type** = `Brand`\<`Uint8Array`, `"Felt252"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/Felt252/types.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/types.ts#L19)

Felt252 - 252-bit field element

The fundamental type in Starknet. All values are elements of the
finite field F_p where p = 2^251 + 17*2^192 + 1.

***

### Int128Input

> **Int128Input** = [`Int128Type`](#int128type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int128/types.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int128/types.ts#L19)

Input types that can be converted to Int128

***

### Int128Type

> **Int128Type** = `Brand`\<`bigint`, `"Int128"`\>

Defined in: [primitives/Int128/types.ts:14](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int128/types.ts#L14)

Int128 - 128-bit signed integer

Represents signed integers in the range [-2^127, 2^127 - 1].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int16Input

> **Int16Input** = [`Int16Type`](#int16type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int16/types.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int16/types.ts#L19)

Input types that can be converted to Int16

***

### Int16Type

> **Int16Type** = `Brand`\<`bigint`, `"Int16"`\>

Defined in: [primitives/Int16/types.ts:14](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int16/types.ts#L14)

Int16 - 16-bit signed integer

Represents signed integers in the range [-32768, 32767].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int32Input

> **Int32Input** = [`Int32Type`](#int32type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int32/types.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int32/types.ts#L19)

Input types that can be converted to Int32

***

### Int32Type

> **Int32Type** = `Brand`\<`bigint`, `"Int32"`\>

Defined in: [primitives/Int32/types.ts:14](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int32/types.ts#L14)

Int32 - 32-bit signed integer

Represents signed integers in the range [-2147483648, 2147483647].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int64Input

> **Int64Input** = [`Int64Type`](#int64type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int64/types.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int64/types.ts#L19)

Input types that can be converted to Int64

***

### Int64Type

> **Int64Type** = `Brand`\<`bigint`, `"Int64"`\>

Defined in: [primitives/Int64/types.ts:14](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int64/types.ts#L14)

Int64 - 64-bit signed integer

Represents signed integers in the range [-2^63, 2^63 - 1].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int8Input

> **Int8Input** = [`Int8Type`](#int8type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int8/types.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int8/types.ts#L19)

Input types that can be converted to Int8

***

### Int8Type

> **Int8Type** = `Brand`\<`bigint`, `"Int8"`\>

Defined in: [primitives/Int8/types.ts:14](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int8/types.ts#L14)

Int8 - 8-bit signed integer

Represents signed integers in the range [-128, 127].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### StorageKeyType

> **StorageKeyType** = `Brand`\<`Uint8Array`, `"StorageKey"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/StorageKey/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/StorageKey/types.ts#L9)

StorageKey - Storage slot address

***

### Uint128Type

> **Uint128Type** = `Brand`\<`bigint`, `"Uint128"`\>

Defined in: [primitives/Uint128/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Uint128/types.ts#L9)

Uint128 - 128-bit unsigned integer
Range: 0 to 2^128 - 1

***

### Uint16Type

> **Uint16Type** = `Brand`\<`bigint`, `"Uint16"`\>

Defined in: [primitives/Uint16/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Uint16/types.ts#L9)

Uint16 - 16-bit unsigned integer
Range: 0 to 65535

***

### Uint256Type

> **Uint256Type** = `Brand`\<`bigint`, `"Uint256"`\>

Defined in: [primitives/Uint256/types.ts:12](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Uint256/types.ts#L12)

Uint256 - 256-bit unsigned integer
Range: 0 to 2^256 - 1

CRITICAL: In Cairo, u256 is serialized as TWO felt252 values: [low, high]
where value = low + high * 2^128

***

### Uint32Type

> **Uint32Type** = `Brand`\<`bigint`, `"Uint32"`\>

Defined in: [primitives/Uint32/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Uint32/types.ts#L9)

Uint32 - 32-bit unsigned integer
Range: 0 to 4294967295

***

### Uint64Type

> **Uint64Type** = `Brand`\<`bigint`, `"Uint64"`\>

Defined in: [primitives/Uint64/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Uint64/types.ts#L9)

Uint64 - 64-bit unsigned integer
Range: 0 to 18446744073709551615

***

### Uint8Type

> **Uint8Type** = `Brand`\<`bigint`, `"Uint8"`\>

Defined in: [primitives/Uint8/types.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Uint8/types.ts#L9)

Uint8 - 8-bit unsigned integer
Range: 0 to 255

## Variables

### BYTE\_ARRAY\_MAGIC

> `const` **BYTE\_ARRAY\_MAGIC**: `1997209042069643135709344952807065910992472029923670688473712229447419591075n` = `0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3n`

Defined in: [primitives/ByteArray/constants.js:5](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/constants.js#L5)

Magic constant for ByteArray serialization (from Cairo)

***

### ByteArray

> `const` **ByteArray**: `object`

Defined in: [primitives/ByteArray/index.ts:32](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/index.ts#L32)

ByteArray namespace with all functions

#### Type Declaration

##### BYTE\_ARRAY\_MAGIC

> **BYTE\_ARRAY\_MAGIC**: `1997209042069643135709344952807065910992472029923670688473712229447419591075n`

Magic constant for ByteArray serialization (from Cairo)

##### BYTES\_PER\_WORD

> **BYTES\_PER\_WORD**: `31`

Number of bytes in a full word

##### from()

> `readonly` **from**: (`bytes`) => [`ByteArrayType`](#bytearraytype) = `_from`

Create ByteArray from Uint8Array

Splits the input into 31-byte words and a pending partial word.

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

Input bytes

###### Returns

[`ByteArrayType`](#bytearraytype)

##### fromString()

> `readonly` **fromString**: (`str`) => [`ByteArrayType`](#bytearraytype) = `_fromString`

Create ByteArray from UTF-8 string

###### Parameters

###### str

`string`

Input string

###### Returns

[`ByteArrayType`](#bytearraytype)

##### length()

> `readonly` **length**: (`byteArray`) => `number` = `_length`

Get the total byte length of a ByteArray

###### Parameters

###### byteArray

[`ByteArrayType`](#bytearraytype)

###### Returns

`number`

##### toBytes()

> `readonly` **toBytes**: (`byteArray`) => `Uint8Array`\<`ArrayBufferLike`\> = `_toBytes`

Convert ByteArray to Uint8Array

###### Parameters

###### byteArray

[`ByteArrayType`](#bytearraytype)

###### Returns

`Uint8Array`\<`ArrayBufferLike`\>

##### toString()

> `readonly` **toString**: (`byteArray`) => `string` = `_toString`

Convert ByteArray to UTF-8 string

###### Parameters

###### byteArray

[`ByteArrayType`](#bytearraytype)

###### Returns

`string`

***

### BYTES\_PER\_WORD

> `const` **BYTES\_PER\_WORD**: `31` = `31`

Defined in: [primitives/ByteArray/constants.js:2](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ByteArray/constants.js#L2)

Number of bytes in a full word

***

### ClassHash

> `const` **ClassHash**: (`felt`) => [`ClassHashType`](#classhashtype) & `object`

Defined in: [primitives/ClassHash/ClassHash.js:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ClassHash/ClassHash.js#L9)

ClassHash namespace with constructor

#### Type Declaration

##### from()

> **from**: (`felt`) => [`ClassHashType`](#classhashtype)

Create a ClassHash from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`ClassHashType`](#classhashtype)

***

### ContractAddress

> `const` **ContractAddress**: (`felt`) => [`ContractAddressType`](#contractaddresstype) & `object`

Defined in: [primitives/ContractAddress/ContractAddress.js:13](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ContractAddress/ContractAddress.js#L13)

ContractAddress namespace with constructor and utilities

#### Type Declaration

##### from()

> **from**: (`felt`) => [`ContractAddressType`](#contractaddresstype)

Create a ContractAddress from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`ContractAddressType`](#contractaddresstype)

##### isValid()

> **isValid**: (`felt`) => `boolean`

Check if input can be a valid contract address

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

`boolean`

##### MAX

> **MAX**: `bigint`

***

### EthAddress

> `const` **EthAddress**: (`felt`) => [`EthAddressType`](#ethaddresstype) & `object`

Defined in: [primitives/EthAddress/EthAddress.js:13](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/EthAddress/EthAddress.js#L13)

EthAddress namespace with constructor and utilities

#### Type Declaration

##### from()

> **from**: (`felt`) => [`EthAddressType`](#ethaddresstype)

Create an EthAddress from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`EthAddressType`](#ethaddresstype)

##### isValid()

> **isValid**: (`felt`) => `boolean`

Check if a value is a valid EthAddress (< 2^160)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

`boolean`

##### MAX

> **MAX**: `bigint`

***

### Felt252

> `const` **Felt252**: (`value`) => [`Felt252Type`](#felt252type) & `object`

Defined in: [primitives/Felt252/Felt252.js:38](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/Felt252.js#L38)

Create a Felt252 from various input types

#### Type Declaration

##### decodeShortString()

> **decodeShortString**: (`felt`) => `string`

Decode a short string from felt

###### Parameters

###### felt

Felt value as bigint, hex string, or Felt252

`string` | `bigint` | [`Felt252Type`](#felt252type)

###### Returns

`string`

Decoded ASCII string

###### Example

```ts
decodeShortString(448378203247n) // 'hello'
decodeShortString('0x68656c6c6f') // 'hello'
```

##### encodeShortString()

> **encodeShortString**: (`str`) => [`Felt252Type`](#felt252type)

Encode a short string to Felt252

Short strings are ASCII strings up to 31 characters that fit in a single felt252.
Each character is encoded as its ASCII value.

###### Parameters

###### str

`string`

ASCII string (max 31 characters)

###### Returns

[`Felt252Type`](#felt252type)

Encoded value as Felt252Type

###### Example

```ts
encodeShortString('hello') // Felt252(448378203247n)
```

##### encodeShortStringHex()

> **encodeShortStringHex**: (`str`) => `string`

Encode a short string to hex

###### Parameters

###### str

`string`

ASCII string (max 31 characters)

###### Returns

`string`

Hex-encoded felt representation (unpadded)

##### equals()

> **equals**: (`a`, `b`) => `boolean`

###### Parameters

###### a

[`Felt252Type`](#felt252type)

###### b

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Felt252Type`](#felt252type)

Create Felt252 from various input types

###### Parameters

###### value

[`Felt252Input`](#felt252input)

###### Returns

[`Felt252Type`](#felt252type)

##### fromBigInt()

> **fromBigInt**: (`value`) => [`Felt252Type`](#felt252type)

Create Felt252 from bigint

###### Parameters

###### value

`bigint`

###### Returns

[`Felt252Type`](#felt252type)

##### fromBytes()

> **fromBytes**: (`bytes`) => [`Felt252Type`](#felt252type)

Create Felt252 from Uint8Array bytes

###### Parameters

###### bytes

`Uint8Array`\<`ArrayBufferLike`\>

###### Returns

[`Felt252Type`](#felt252type)

##### fromHex()

> **fromHex**: (`hex`) => [`Felt252Type`](#felt252type)

Create Felt252 from hex string

###### Parameters

###### hex

`string`

###### Returns

[`Felt252Type`](#felt252type)

##### isValid()

> **isValid**: (`felt`) => `boolean`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`felt`) => `boolean`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### MAX\_SHORT\_STRING\_LENGTH

> **MAX\_SHORT\_STRING\_LENGTH**: `number`

##### ONE

> **ONE**: [`Felt252Type`](#felt252type)

##### PRIME

> **PRIME**: `bigint`

##### toBigInt()

> **toBigInt**: (`felt`) => `bigint`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`bigint`

##### toHex()

> **toHex**: (`felt`) => `string`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`string`

##### TWO

> **TWO**: [`Felt252Type`](#felt252type)

##### ZERO

> **ZERO**: [`Felt252Type`](#felt252type)

***

### feltAdd()

> `const` **feltAdd**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:11](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L11)

Add two felts (a + b mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type), [`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltDiv()

> `const` **feltDiv**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:35](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L35)

Divide two felts (a / b mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type), [`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltInverse()

> `const` **feltInverse**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:51](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L51)

Multiplicative inverse (1/a mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltMul()

> `const` **feltMul**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:27](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L27)

Multiply two felts (a * b mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type), [`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltNeg()

> `const` **feltNeg**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:43](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L43)

Negate a felt (-a mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltPow()

> `const` **feltPow**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:59](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L59)

Power (base^exp mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type), [`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltSqrt()

> `const` **feltSqrt**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:67](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L67)

Square root (returns sqrt if exists)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### feltSub()

> `const` **feltSub**: (...`args`) => [`Felt252Type`](#felt252type)

Defined in: [crypto/arithmetic.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/arithmetic.ts#L19)

Subtract two felts (a - b mod P)

#### Parameters

##### args

...\[[`Felt252Type`](#felt252type), [`Felt252Type`](#felt252type)\]

#### Returns

[`Felt252Type`](#felt252type)

***

### FIELD\_PRIME

> `const` **FIELD\_PRIME**: `bigint` = `0x800000000000011000000000000000000000000000000000000000000000001n`

Defined in: [primitives/Felt252/constants.js:5](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/constants.js#L5)

Field prime P = 2^251 + 17*2^192 + 1

***

### Int128

> `const` **Int128**: (`value`) => [`Int128Type`](#int128type) & `object`

Defined in: [primitives/Int128/Int128.js:16](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int128/Int128.js#L16)

Utility functions for Int128 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int128 values are equal

###### Parameters

###### a

[`Int128Type`](#int128type)

###### b

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int128Type`](#int128type)

Create an Int128 from various input types.

###### Parameters

###### value

[`Int128Input`](#int128input)

The value to convert (bigint, number, or string)

###### Returns

[`Int128Type`](#int128type)

A branded Int128Type

###### Throws

if value is outside [MIN, MAX]

###### Throws

if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int128Type`](#int128type)

Decode a Felt252 back to an Int128.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int128Type`](#int128type)

The signed Int128 value

###### Throws

if the decoded value is outside Int128 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int128 is negative (< 0)

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int128 is positive (> 0)

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int128 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int128 is zero

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int128Type`](#int128type) = `int128Max`

##### MIN

> **MIN**: [`Int128Type`](#int128type) = `int128Min`

##### ONE

> **ONE**: [`Int128Type`](#int128type) = `int128One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int128

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int128 to its bigint value.

###### Parameters

###### value

[`Int128Type`](#int128type)

The Int128 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int128 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int128Type`](#int128type)

The Int128 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int128 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int128Type`](#int128type)

The Int128 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int128Type`](#int128type) = `int128Zero`

***

### Int16

> `const` **Int16**: (`value`) => [`Int16Type`](#int16type) & `object`

Defined in: [primitives/Int16/Int16.js:16](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int16/Int16.js#L16)

Utility functions for Int16 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int16 values are equal

###### Parameters

###### a

[`Int16Type`](#int16type)

###### b

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int16Type`](#int16type)

Create an Int16 from various input types.

###### Parameters

###### value

[`Int16Input`](#int16input)

The value to convert (bigint, number, or string)

###### Returns

[`Int16Type`](#int16type)

A branded Int16Type

###### Throws

if value is outside [MIN, MAX]

###### Throws

if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int16Type`](#int16type)

Decode a Felt252 back to an Int16.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int16Type`](#int16type)

The signed Int16 value

###### Throws

if the decoded value is outside Int16 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int16 is negative (< 0)

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int16 is positive (> 0)

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int16 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int16 is zero

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int16Type`](#int16type) = `int16Max`

##### MIN

> **MIN**: [`Int16Type`](#int16type) = `int16Min`

##### ONE

> **ONE**: [`Int16Type`](#int16type) = `int16One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int16

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int16 to its bigint value.

###### Parameters

###### value

[`Int16Type`](#int16type)

The Int16 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int16 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int16Type`](#int16type)

The Int16 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int16 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int16Type`](#int16type)

The Int16 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int16Type`](#int16type) = `int16Zero`

***

### Int32

> `const` **Int32**: (`value`) => [`Int32Type`](#int32type) & `object`

Defined in: [primitives/Int32/Int32.js:16](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int32/Int32.js#L16)

Utility functions for Int32 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int32 values are equal

###### Parameters

###### a

[`Int32Type`](#int32type)

###### b

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int32Type`](#int32type)

Create an Int32 from various input types.

###### Parameters

###### value

[`Int32Input`](#int32input)

The value to convert (bigint, number, or string)

###### Returns

[`Int32Type`](#int32type)

A branded Int32Type

###### Throws

if value is outside [MIN, MAX]

###### Throws

if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int32Type`](#int32type)

Decode a Felt252 back to an Int32.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int32Type`](#int32type)

The signed Int32 value

###### Throws

if the decoded value is outside Int32 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int32 is negative (< 0)

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int32 is positive (> 0)

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int32 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int32 is zero

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int32Type`](#int32type) = `int32Max`

##### MIN

> **MIN**: [`Int32Type`](#int32type) = `int32Min`

##### ONE

> **ONE**: [`Int32Type`](#int32type) = `int32One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int32

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int32 to its bigint value.

###### Parameters

###### value

[`Int32Type`](#int32type)

The Int32 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int32 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int32Type`](#int32type)

The Int32 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int32 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int32Type`](#int32type)

The Int32 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int32Type`](#int32type) = `int32Zero`

***

### Int64

> `const` **Int64**: (`value`) => [`Int64Type`](#int64type) & `object`

Defined in: [primitives/Int64/Int64.js:16](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int64/Int64.js#L16)

Utility functions for Int64 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int64 values are equal

###### Parameters

###### a

[`Int64Type`](#int64type)

###### b

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int64Type`](#int64type)

Create an Int64 from various input types.

###### Parameters

###### value

[`Int64Input`](#int64input)

The value to convert (bigint, number, or string)

###### Returns

[`Int64Type`](#int64type)

A branded Int64Type

###### Throws

if value is outside [MIN, MAX]

###### Throws

if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int64Type`](#int64type)

Decode a Felt252 back to an Int64.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int64Type`](#int64type)

The signed Int64 value

###### Throws

if the decoded value is outside Int64 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int64 is negative (< 0)

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int64 is positive (> 0)

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int64 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int64 is zero

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int64Type`](#int64type) = `int64Max`

##### MIN

> **MIN**: [`Int64Type`](#int64type) = `int64Min`

##### ONE

> **ONE**: [`Int64Type`](#int64type) = `int64One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int64

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int64 to its bigint value.

###### Parameters

###### value

[`Int64Type`](#int64type)

The Int64 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int64 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int64Type`](#int64type)

The Int64 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int64 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int64Type`](#int64type)

The Int64 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int64Type`](#int64type) = `int64Zero`

***

### Int8

> `const` **Int8**: (`value`) => [`Int8Type`](#int8type) & `object`

Defined in: [primitives/Int8/Int8.js:16](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Int8/Int8.js#L16)

Utility functions for Int8 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int8 values are equal

###### Parameters

###### a

[`Int8Type`](#int8type)

###### b

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int8Type`](#int8type)

Create an Int8 from various input types.

###### Parameters

###### value

[`Int8Input`](#int8input)

The value to convert (bigint, number, or string)

###### Returns

[`Int8Type`](#int8type)

A branded Int8Type

###### Throws

if value is outside [MIN, MAX]

###### Throws

if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int8Type`](#int8type)

Decode a Felt252 back to an Int8.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int8Type`](#int8type)

The signed Int8 value

###### Throws

if the decoded value is outside Int8 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int8 is negative (< 0)

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int8 is positive (> 0)

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int8 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int8 is zero

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int8Type`](#int8type) = `int8Max`

##### MIN

> **MIN**: [`Int8Type`](#int8type) = `int8Min`

##### ONE

> **ONE**: [`Int8Type`](#int8type) = `int8One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int8

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int8 to its bigint value.

###### Parameters

###### value

[`Int8Type`](#int8type)

The Int8 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int8 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int8Type`](#int8type)

The Int8 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int8 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int8Type`](#int8type)

The Int8 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int8Type`](#int8type) = `int8Zero`

***

### MAX\_CONTRACT\_ADDRESS

> `const` **MAX\_CONTRACT\_ADDRESS**: `bigint`

Defined in: [primitives/ContractAddress/constants.js:5](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ContractAddress/constants.js#L5)

Maximum valid contract address (< 2^251)

***

### MAX\_ETH\_ADDRESS

> `const` **MAX\_ETH\_ADDRESS**: `bigint`

Defined in: [primitives/EthAddress/constants.js:5](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/EthAddress/constants.js#L5)

Maximum valid ETH address (< 2^160)

***

### MAX\_SHORT\_STRING\_LENGTH

> `const` **MAX\_SHORT\_STRING\_LENGTH**: `number` = `31`

Defined in: [primitives/Felt252/constants.js:13](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/Felt252/constants.js#L13)

Maximum length for short strings (31 characters)
Short strings are ASCII strings that fit in a single felt252

***

### Pedersen

> `const` **Pedersen**: `object`

Defined in: [crypto/Pedersen/index.ts:6](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/Pedersen/index.ts#L6)

#### Type Declaration

##### hash()

> **hash**: (`a`, `b`) => [`Felt252Type`](#felt252type)

Pedersen hash of two felts (pure JS)

###### Parameters

###### a

[`Felt252Type`](#felt252type)

###### b

[`Felt252Type`](#felt252type)

###### Returns

[`Felt252Type`](#felt252type)

##### hashMany()

> **hashMany**: (`values`) => [`Felt252Type`](#felt252type)

Pedersen hash of array (chained)

###### Parameters

###### values

[`Felt252Type`](#felt252type)[]

###### Returns

[`Felt252Type`](#felt252type)

***

### Poseidon

> `const` **Poseidon**: `object`

Defined in: [crypto/Poseidon/index.ts:6](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/Poseidon/index.ts#L6)

#### Type Declaration

##### hash()

> **hash**: (`a`, `b`) => [`Felt252Type`](#felt252type)

Poseidon hash of two felts (pure JS)

###### Parameters

###### a

[`Felt252Type`](#felt252type)

###### b

[`Felt252Type`](#felt252type)

###### Returns

[`Felt252Type`](#felt252type)

##### hashMany()

> **hashMany**: (`values`) => [`Felt252Type`](#felt252type)

Poseidon hash of array

###### Parameters

###### values

[`Felt252Type`](#felt252type)[]

###### Returns

[`Felt252Type`](#felt252type)

***

### StarkCurve

> `const` **StarkCurve**: `object`

Defined in: [crypto/namespaces/StarkCurve.ts:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/namespaces/StarkCurve.ts#L9)

#### Type Declaration

##### getPublicKey()

> **getPublicKey**: (`privateKey`) => [`Felt252Type`](#felt252type)

Derive public key from private key (pure JS)

Returns the X-coordinate of the public key point (Starknet convention).

###### Parameters

###### privateKey

[`Felt252Type`](#felt252type)

Private key

###### Returns

[`Felt252Type`](#felt252type)

Public key (x-coordinate)

##### recover()

> **recover**: (`messageHash`, `r`, `s`, `v`) => [`Felt252Type`](#felt252type)

Recover public key from signature (pure JS)

Uses @scure/starknet Signature.recoverPublicKey.
Returns the X-coordinate of the recovered public key (Starknet convention).

###### Parameters

###### messageHash

[`Felt252Type`](#felt252type)

Message hash

###### r

[`Felt252Type`](#felt252type)

Signature r component

###### s

[`Felt252Type`](#felt252type)

Signature s component

###### v

[`Felt252Type`](#felt252type)

Recovery parameter (0 or 1)

###### Returns

[`Felt252Type`](#felt252type)

Recovered public key (x-coordinate)

###### Throws

If recovery fails

##### sign()

> **sign**: (`privateKey`, `messageHash`) => [`Signature`](#signature)

Sign a message hash with STARK curve ECDSA (pure JS)

###### Parameters

###### privateKey

[`Felt252Type`](#felt252type)

Private key

###### messageHash

[`Felt252Type`](#felt252type)

Message hash to sign

###### Returns

[`Signature`](#signature)

Signature with r and s components

##### verify()

> **verify**: (`publicKey`, `messageHash`, `signature`) => `boolean`

Verify a STARK curve ECDSA signature (pure JS)

Accepts either:
- Full uncompressed public key (65 bytes Uint8Array)
- X-coordinate only (Felt252Type) - will try both Y values via recovery

###### Parameters

###### publicKey

Public key

[`Felt252Type`](#felt252type) | `Uint8Array`\<`ArrayBufferLike`\>

###### messageHash

[`Felt252Type`](#felt252type)

Message hash that was signed

###### signature

[`Signature`](#signature) & `object`

Signature to verify

###### Returns

`boolean`

True if signature is valid

***

### StorageKey

> `const` **StorageKey**: (`felt`) => [`StorageKeyType`](#storagekeytype) & `object`

Defined in: [primitives/StorageKey/StorageKey.js:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/StorageKey/StorageKey.js#L9)

StorageKey namespace with constructor

#### Type Declaration

##### from()

> **from**: (`felt`) => [`StorageKeyType`](#storagekeytype)

Create a StorageKey from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`StorageKeyType`](#storagekeytype)

## Functions

### decodeShortString()

> **decodeShortString**(`felt`): `string`

Defined in: [primitives/ShortString/decodeShortString.js:13](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ShortString/decodeShortString.js#L13)

Decode a short string from felt

#### Parameters

##### felt

Felt value as bigint, hex string, or Felt252

`string` | `bigint` | [`Felt252Type`](#felt252type)

#### Returns

`string`

Decoded ASCII string

#### Example

```ts
decodeShortString(448378203247n) // 'hello'
decodeShortString('0x68656c6c6f') // 'hello'
```

***

### encodeShortString()

> **encodeShortString**(`str`): [`Felt252Type`](#felt252type)

Defined in: [primitives/ShortString/encodeShortString.js:30](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ShortString/encodeShortString.js#L30)

Encode a short string to Felt252

Short strings are ASCII strings up to 31 characters that fit in a single felt252.
Each character is encoded as its ASCII value.

#### Parameters

##### str

`string`

ASCII string (max 31 characters)

#### Returns

[`Felt252Type`](#felt252type)

Encoded value as Felt252Type

#### Example

```ts
encodeShortString('hello') // Felt252(448378203247n)
```

***

### encodeShortStringHex()

> **encodeShortStringHex**(`str`): `string`

Defined in: [primitives/ShortString/encodeShortStringHex.js:9](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/primitives/ShortString/encodeShortStringHex.js#L9)

Encode a short string to hex

#### Parameters

##### str

`string`

ASCII string (max 31 characters)

#### Returns

`string`

Hex-encoded felt representation (unpadded)

***

### getPublicKey()

> **getPublicKey**(`privateKey`): [`Felt252Type`](#felt252type)

Defined in: [crypto/ECDSA/getPublicKey.js:13](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/getPublicKey.js#L13)

Derive public key from private key (pure JS)

Returns the X-coordinate of the public key point (Starknet convention).

#### Parameters

##### privateKey

[`Felt252Type`](#felt252type)

Private key

#### Returns

[`Felt252Type`](#felt252type)

Public key (x-coordinate)

***

### isNativeAvailable()

> **isNativeAvailable**(): `boolean`

Defined in: [crypto/availability.ts:12](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/availability.ts#L12)

Check if native crypto is available

#### Returns

`boolean`

***

### isWasmAvailable()

> **isWasmAvailable**(): `boolean`

Defined in: [crypto/availability.ts:19](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/availability.ts#L19)

Check if WASM crypto is available (file exists)

#### Returns

`boolean`

***

### isWasmLoaded()

> **isWasmLoaded**(): `boolean`

Defined in: [crypto/availability.ts:27](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/availability.ts#L27)

Check if WASM crypto is loaded

#### Returns

`boolean`

***

### loadWasmCrypto()

> **loadWasmCrypto**(): `Promise`\<`void`\>

Defined in: [crypto/availability.ts:35](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/availability.ts#L35)

Load WASM crypto module
Call this before using crypto functions if native is not available.

#### Returns

`Promise`\<`void`\>

***

### pedersenHash()

> **pedersenHash**(`a`, `b`): [`Felt252Type`](#felt252type)

Defined in: [crypto/Pedersen/hash.js:10](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/Pedersen/hash.js#L10)

Pedersen hash of two felts (pure JS)

#### Parameters

##### a

[`Felt252Type`](#felt252type)

##### b

[`Felt252Type`](#felt252type)

#### Returns

[`Felt252Type`](#felt252type)

***

### poseidonHash()

> **poseidonHash**(`a`, `b`): [`Felt252Type`](#felt252type)

Defined in: [crypto/Poseidon/hash.js:10](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/Poseidon/hash.js#L10)

Poseidon hash of two felts (pure JS)

#### Parameters

##### a

[`Felt252Type`](#felt252type)

##### b

[`Felt252Type`](#felt252type)

#### Returns

[`Felt252Type`](#felt252type)

***

### poseidonHashMany()

> **poseidonHashMany**(`values`): [`Felt252Type`](#felt252type)

Defined in: [crypto/Poseidon/hash.js:20](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/Poseidon/hash.js#L20)

Poseidon hash of array

#### Parameters

##### values

[`Felt252Type`](#felt252type)[]

#### Returns

[`Felt252Type`](#felt252type)

***

### recover()

> **recover**(`messageHash`, `r`, `s`, `v`): [`Felt252Type`](#felt252type)

Defined in: [crypto/ECDSA/recover.js:18](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/recover.js#L18)

Recover public key from signature (pure JS)

Uses @scure/starknet Signature.recoverPublicKey.
Returns the X-coordinate of the recovered public key (Starknet convention).

#### Parameters

##### messageHash

[`Felt252Type`](#felt252type)

Message hash

##### r

[`Felt252Type`](#felt252type)

Signature r component

##### s

[`Felt252Type`](#felt252type)

Signature s component

##### v

[`Felt252Type`](#felt252type)

Recovery parameter (0 or 1)

#### Returns

[`Felt252Type`](#felt252type)

Recovered public key (x-coordinate)

#### Throws

If recovery fails

***

### sign()

> **sign**(`privateKey`, `messageHash`): [`Signature`](#signature)

Defined in: [crypto/ECDSA/sign.js:12](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/sign.js#L12)

Sign a message hash with STARK curve ECDSA (pure JS)

#### Parameters

##### privateKey

[`Felt252Type`](#felt252type)

Private key

##### messageHash

[`Felt252Type`](#felt252type)

Message hash to sign

#### Returns

[`Signature`](#signature)

Signature with r and s components

***

### verify()

> **verify**(`publicKey`, `messageHash`, `signature`): `boolean`

Defined in: [crypto/ECDSA/verify.js:17](https://github.com/enitrat/kundera/blob/5dad53c21d460e04f0e31a51bbcb51ca53c6fe8d/packages/kundera-ts/src/crypto/ECDSA/verify.js#L17)

Verify a STARK curve ECDSA signature (pure JS)

Accepts either:
- Full uncompressed public key (65 bytes Uint8Array)
- X-coordinate only (Felt252Type) - will try both Y values via recovery

#### Parameters

##### publicKey

Public key

[`Felt252Type`](#felt252type) | `Uint8Array`\<`ArrayBufferLike`\>

##### messageHash

[`Felt252Type`](#felt252type)

Message hash that was signed

##### signature

[`Signature`](#signature) & `object`

Signature to verify

#### Returns

`boolean`

True if signature is valid

## References

### Address

Re-exports [Address](primitives.mdx#address)

***

### CairoSerde

Re-exports [CairoSerde](serde.mdx#cairoserde)

***

### Class

Re-exports [Class](primitives.mdx#class)

***

### deserializeArray

Re-exports [deserializeArray](serde.mdx#deserializearray-1)

***

### deserializeU256

Re-exports [deserializeU256](serde.mdx#deserializeu256-1)

***

### Felt

Re-exports [Felt](crypto.mdx#felt)

***

### MAX\_ADDRESS

Re-exports [MAX_ADDRESS](primitives.mdx#max_address)

***

### serializeArray

Re-exports [serializeArray](serde.mdx#serializearray-1)

***

### serializeByteArray

Re-exports [serializeByteArray](serde.mdx#serializebytearray-1)

***

### serializeU256

Re-exports [serializeU256](serde.mdx#serializeu256-1)

***

### snKeccak

Re-exports [snKeccak](crypto.mdx#snkeccak)

***

### Storage

Re-exports [Storage](primitives.mdx#storage)

***

### Uint128

Re-exports [Uint128](primitives/Uint128.mdx#uint128)

***

### Uint16

Re-exports [Uint16](primitives/Uint16.mdx#uint16)

***

### Uint256

Re-exports [Uint256](primitives/Uint256.mdx#uint256)

***

### Uint32

Re-exports [Uint32](primitives/Uint32.mdx#uint32)

***

### Uint64

Re-exports [Uint64](primitives/Uint64.mdx#uint64)

***

### Uint8

Re-exports [Uint8](primitives/Uint8.mdx#uint8)
