---
title: "index"
description: Auto-generated API documentation
---

[**@kundera-sn/kundera-ts**](index.mdx)

***

[@kundera-sn/kundera-ts](index.mdx) / index

# index

Kundera - Starknet Primitives Library

A high-performance library for Starknet types and cryptography.
Architecture: TypeScript API â†’ Rust FFI (starknet-crypto)

## Interfaces

### FeltMethods

Defined in: [primitives/Felt252/types.ts:5](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L5)

#### Methods

##### equals()

> **equals**(`other`): `boolean`

Defined in: [primitives/Felt252/types.ts:10](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L10)

###### Parameters

###### other

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### isValid()

> **isValid**(): `boolean`

Defined in: [primitives/Felt252/types.ts:8](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L8)

###### Returns

`boolean`

##### isZero()

> **isZero**(): `boolean`

Defined in: [primitives/Felt252/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L9)

###### Returns

`boolean`

##### toBigInt()

> **toBigInt**(): `bigint`

Defined in: [primitives/Felt252/types.ts:7](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L7)

###### Returns

`bigint`

##### toHex()

> **toHex**(): `string`

Defined in: [primitives/Felt252/types.ts:6](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L6)

###### Returns

`string`

## Type Aliases

### ClassHashType

> **ClassHashType** = `Brand`\<`Uint8Array`, `"ClassHash"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/ClassHash/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ClassHash/types.ts#L9)

ClassHash - Contract class identifier

***

### ContractAddressType

> **ContractAddressType** = `Brand`\<`Uint8Array`, `"ContractAddress"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/ContractAddress/types.ts:10](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ContractAddress/types.ts#L10)

ContractAddress - Starknet contract address
Must be < 2^251

***

### EthAddressType

> **EthAddressType** = `Brand`\<`Uint8Array`, `"EthAddress"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/EthAddress/types.ts:10](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/EthAddress/types.ts#L10)

EthAddress - L1 Ethereum address used in L1-L2 messaging
Must be < 2^160

***

### Felt252Input

> **Felt252Input** = [`Felt252Type`](#felt252type) \| `Uint8Array` \| `string` \| `bigint` \| `number`

Defined in: [primitives/Felt252/types.ts:24](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L24)

Input types that can be converted to Felt252

***

### Felt252Type

> **Felt252Type** = `Brand`\<`Uint8Array`, `"Felt252"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/Felt252/types.ts:19](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/types.ts#L19)

Felt252 - 252-bit field element

The fundamental type in Starknet. All values are elements of the
finite field F_p where p = 2^251 + 17*2^192 + 1.

***

### Int128Input

> **Int128Input** = [`Int128Type`](#int128type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int128/types.ts:19](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int128/types.ts#L19)

Input types that can be converted to Int128

***

### Int128Type

> **Int128Type** = `Brand`\<`bigint`, `"Int128"`\>

Defined in: [primitives/Int128/types.ts:14](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int128/types.ts#L14)

Int128 - 128-bit signed integer

Represents signed integers in the range [-2^127, 2^127 - 1].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int16Input

> **Int16Input** = [`Int16Type`](#int16type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int16/types.ts:19](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int16/types.ts#L19)

Input types that can be converted to Int16

***

### Int16Type

> **Int16Type** = `Brand`\<`bigint`, `"Int16"`\>

Defined in: [primitives/Int16/types.ts:14](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int16/types.ts#L14)

Int16 - 16-bit signed integer

Represents signed integers in the range [-32768, 32767].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int32Input

> **Int32Input** = [`Int32Type`](#int32type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int32/types.ts:19](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int32/types.ts#L19)

Input types that can be converted to Int32

***

### Int32Type

> **Int32Type** = `Brand`\<`bigint`, `"Int32"`\>

Defined in: [primitives/Int32/types.ts:14](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int32/types.ts#L14)

Int32 - 32-bit signed integer

Represents signed integers in the range [-2147483648, 2147483647].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int64Input

> **Int64Input** = [`Int64Type`](#int64type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int64/types.ts:19](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int64/types.ts#L19)

Input types that can be converted to Int64

***

### Int64Type

> **Int64Type** = `Brand`\<`bigint`, `"Int64"`\>

Defined in: [primitives/Int64/types.ts:14](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int64/types.ts#L14)

Int64 - 64-bit signed integer

Represents signed integers in the range [-2^63, 2^63 - 1].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### Int8Input

> **Int8Input** = [`Int8Type`](#int8type) \| `bigint` \| `number` \| `string`

Defined in: [primitives/Int8/types.ts:19](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int8/types.ts#L19)

Input types that can be converted to Int8

***

### Int8Type

> **Int8Type** = `Brand`\<`bigint`, `"Int8"`\>

Defined in: [primitives/Int8/types.ts:14](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int8/types.ts#L14)

Int8 - 8-bit signed integer

Represents signed integers in the range [-128, 127].
Internally stores the signed value as a bigint.

IMPORTANT: Cairo uses prime field encoding for negative values,
NOT two's complement. Use toFelt() for Cairo-compatible encoding.

***

### StorageKeyType

> **StorageKeyType** = `Brand`\<`Uint8Array`, `"StorageKey"`\> & [`FeltMethods`](#feltmethods)

Defined in: [primitives/StorageKey/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/StorageKey/types.ts#L9)

StorageKey - Storage slot address

***

### Uint128Type

> **Uint128Type** = `Brand`\<`bigint`, `"Uint128"`\>

Defined in: [primitives/Uint128/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Uint128/types.ts#L9)

Uint128 - 128-bit unsigned integer
Range: 0 to 2^128 - 1

***

### Uint16Type

> **Uint16Type** = `Brand`\<`bigint`, `"Uint16"`\>

Defined in: [primitives/Uint16/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Uint16/types.ts#L9)

Uint16 - 16-bit unsigned integer
Range: 0 to 65535

***

### Uint256Type

> **Uint256Type** = `Brand`\<`bigint`, `"Uint256"`\>

Defined in: [primitives/Uint256/types.ts:12](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Uint256/types.ts#L12)

Uint256 - 256-bit unsigned integer
Range: 0 to 2^256 - 1

CRITICAL: In Cairo, u256 is serialized as TWO felt252 values: [low, high]
where value = low + high * 2^128

***

### Uint32Type

> **Uint32Type** = `Brand`\<`bigint`, `"Uint32"`\>

Defined in: [primitives/Uint32/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Uint32/types.ts#L9)

Uint32 - 32-bit unsigned integer
Range: 0 to 4294967295

***

### Uint64Type

> **Uint64Type** = `Brand`\<`bigint`, `"Uint64"`\>

Defined in: [primitives/Uint64/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Uint64/types.ts#L9)

Uint64 - 64-bit unsigned integer
Range: 0 to 18446744073709551615

***

### Uint8Type

> **Uint8Type** = `Brand`\<`bigint`, `"Uint8"`\>

Defined in: [primitives/Uint8/types.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Uint8/types.ts#L9)

Uint8 - 8-bit unsigned integer
Range: 0 to 255

## Variables

### ClassHash

> `const` **ClassHash**: (`felt`) => [`ClassHashType`](#classhashtype) & `object`

Defined in: [primitives/ClassHash/ClassHash.ts:3](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ClassHash/ClassHash.ts#L3)

#### Type Declaration

##### from()

> **from**: (`felt`) => [`ClassHashType`](#classhashtype)

Create a ClassHash from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`ClassHashType`](#classhashtype)

***

### ContractAddress

> `const` **ContractAddress**: (`felt`) => [`ContractAddressType`](#contractaddresstype) & `object`

Defined in: [primitives/ContractAddress/ContractAddress.ts:5](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ContractAddress/ContractAddress.ts#L5)

#### Type Declaration

##### from()

> **from**: (`felt`) => [`ContractAddressType`](#contractaddresstype)

Create a ContractAddress from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`ContractAddressType`](#contractaddresstype)

##### isValid()

> **isValid**: (`felt`) => `boolean`

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

`boolean`

##### MAX

> **MAX**: `bigint` = `MAX_CONTRACT_ADDRESS`

***

### EthAddress

> `const` **EthAddress**: (`felt`) => [`EthAddressType`](#ethaddresstype) & `object`

Defined in: [primitives/EthAddress/EthAddress.ts:5](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/EthAddress/EthAddress.ts#L5)

#### Type Declaration

##### from()

> **from**: (`felt`) => [`EthAddressType`](#ethaddresstype)

Create an EthAddress from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`EthAddressType`](#ethaddresstype)

##### isValid()

> **isValid**: (`felt`) => `boolean`

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

`boolean`

##### MAX

> **MAX**: `bigint` = `MAX_ETH_ADDRESS`

***

### Felt252

> `const` **Felt252**: (`value`) => [`Felt252Type`](#felt252type) & `object`

Defined in: [primitives/Felt252/Felt252.ts:20](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/Felt252.ts#L20)

Create a Felt252 from various input types

#### Type Declaration

##### decodeShortString()

> **decodeShortString**: (`felt`) => `string`

Decode a short string from felt

###### Parameters

###### felt

Felt value as bigint, hex string, or Felt252

`string` | `bigint` | [`Felt252Type`](#felt252type)

###### Returns

`string`

Decoded ASCII string

###### Example

```ts
decodeShortString(448378203247n) // 'hello'
decodeShortString('0x68656c6c6f') // 'hello'
```

##### encodeShortString()

> **encodeShortString**: (`str`) => [`Felt252Type`](#felt252type)

Encode a short string to Felt252

Short strings are ASCII strings up to 31 characters that fit in a single felt252.
Each character is encoded as its ASCII value.

###### Parameters

###### str

`string`

ASCII string (max 31 characters)

###### Returns

[`Felt252Type`](#felt252type)

Encoded value as Felt252Type

###### Example

```ts
encodeShortString('hello') // Felt252(448378203247n)
```

##### encodeShortStringHex()

> **encodeShortStringHex**: (`str`) => `string`

Encode a short string to hex

###### Parameters

###### str

`string`

ASCII string (max 31 characters)

###### Returns

`string`

Hex-encoded felt representation (unpadded)

##### equals()

> **equals**: (`a`, `b`) => `boolean`

###### Parameters

###### a

[`Felt252Type`](#felt252type)

###### b

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Felt252Type`](#felt252type)

###### Parameters

###### value

[`Felt252Input`](#felt252input)

###### Returns

[`Felt252Type`](#felt252type)

##### fromBigInt()

> **fromBigInt**: (`value`) => [`Felt252Type`](#felt252type)

###### Parameters

###### value

`bigint`

###### Returns

[`Felt252Type`](#felt252type)

##### fromBytes()

> **fromBytes**: (`bytes`) => [`Felt252Type`](#felt252type)

###### Parameters

###### bytes

`Uint8Array`

###### Returns

[`Felt252Type`](#felt252type)

##### fromHex()

> **fromHex**: (`hex`) => [`Felt252Type`](#felt252type)

###### Parameters

###### hex

`string`

###### Returns

[`Felt252Type`](#felt252type)

##### isValid()

> **isValid**: (`felt`) => `boolean`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`felt`) => `boolean`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`boolean`

##### MAX\_SHORT\_STRING\_LENGTH

> **MAX\_SHORT\_STRING\_LENGTH**: `number`

Maximum length for short strings (31 characters)
Short strings are ASCII strings that fit in a single felt252

##### ONE

> **ONE**: [`Felt252Type`](#felt252type) = `feltOne`

##### PRIME

> **PRIME**: `bigint` = `FIELD_PRIME`

##### toBigInt()

> **toBigInt**: (`felt`) => `bigint`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`bigint`

##### toHex()

> **toHex**: (`felt`) => `string`

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

###### Returns

`string`

##### TWO

> **TWO**: [`Felt252Type`](#felt252type) = `feltTwo`

##### ZERO

> **ZERO**: [`Felt252Type`](#felt252type) = `feltZero`

***

### FIELD\_PRIME

> `const` **FIELD\_PRIME**: `3618502788666131213697322783095070105623107215331596699973092056135872020481n` = `0x800000000000011000000000000000000000000000000000000000000000001n`

Defined in: [primitives/Felt252/constants.ts:4](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/constants.ts#L4)

Field prime P = 2^251 + 17*2^192 + 1

***

### Int128

> `const` **Int128**: (`value`) => [`Int128Type`](#int128type) & `object`

Defined in: [primitives/Int128/Int128.ts:17](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int128/Int128.ts#L17)

Utility functions for Int128 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int128 values are equal

###### Parameters

###### a

[`Int128Type`](#int128type)

###### b

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int128Type`](#int128type)

Create an Int128 from various input types.

###### Parameters

###### value

[`Int128Input`](#int128input)

The value to convert (bigint, number, or string)

###### Returns

[`Int128Type`](#int128type)

A branded Int128Type

###### Throws

Int128RangeError if value is outside [MIN, MAX]

###### Throws

Int128ParseError if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int128Type`](#int128type)

Decode a Felt252 back to an Int128.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int128Type`](#int128type)

The signed Int128 value

###### Throws

Int128RangeError if the decoded value is outside Int128 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int128 is negative (< 0)

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int128 is positive (> 0)

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int128 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int128 is zero

###### Parameters

###### value

[`Int128Type`](#int128type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int128Type`](#int128type) = `int128Max`

##### MIN

> **MIN**: [`Int128Type`](#int128type) = `int128Min`

##### ONE

> **ONE**: [`Int128Type`](#int128type) = `int128One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int128

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int128 to its bigint value.

###### Parameters

###### value

[`Int128Type`](#int128type)

The Int128 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int128 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int128Type`](#int128type)

The Int128 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int128 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int128Type`](#int128type)

The Int128 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int128Type`](#int128type) = `int128Zero`

***

### Int16

> `const` **Int16**: (`value`) => [`Int16Type`](#int16type) & `object`

Defined in: [primitives/Int16/Int16.ts:17](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int16/Int16.ts#L17)

Utility functions for Int16 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int16 values are equal

###### Parameters

###### a

[`Int16Type`](#int16type)

###### b

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int16Type`](#int16type)

Create an Int16 from various input types.

###### Parameters

###### value

[`Int16Input`](#int16input)

The value to convert (bigint, number, or string)

###### Returns

[`Int16Type`](#int16type)

A branded Int16Type

###### Throws

Int16RangeError if value is outside [MIN, MAX]

###### Throws

Int16ParseError if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int16Type`](#int16type)

Decode a Felt252 back to an Int16.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int16Type`](#int16type)

The signed Int16 value

###### Throws

Int16RangeError if the decoded value is outside Int16 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int16 is negative (< 0)

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int16 is positive (> 0)

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int16 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int16 is zero

###### Parameters

###### value

[`Int16Type`](#int16type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int16Type`](#int16type) = `int16Max`

##### MIN

> **MIN**: [`Int16Type`](#int16type) = `int16Min`

##### ONE

> **ONE**: [`Int16Type`](#int16type) = `int16One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int16

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int16 to its bigint value.

###### Parameters

###### value

[`Int16Type`](#int16type)

The Int16 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int16 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int16Type`](#int16type)

The Int16 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int16 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int16Type`](#int16type)

The Int16 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int16Type`](#int16type) = `int16Zero`

***

### Int32

> `const` **Int32**: (`value`) => [`Int32Type`](#int32type) & `object`

Defined in: [primitives/Int32/Int32.ts:17](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int32/Int32.ts#L17)

Utility functions for Int32 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int32 values are equal

###### Parameters

###### a

[`Int32Type`](#int32type)

###### b

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int32Type`](#int32type)

Create an Int32 from various input types.

###### Parameters

###### value

[`Int32Input`](#int32input)

The value to convert (bigint, number, or string)

###### Returns

[`Int32Type`](#int32type)

A branded Int32Type

###### Throws

Int32RangeError if value is outside [MIN, MAX]

###### Throws

Int32ParseError if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int32Type`](#int32type)

Decode a Felt252 back to an Int32.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int32Type`](#int32type)

The signed Int32 value

###### Throws

Int32RangeError if the decoded value is outside Int32 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int32 is negative (< 0)

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int32 is positive (> 0)

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int32 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int32 is zero

###### Parameters

###### value

[`Int32Type`](#int32type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int32Type`](#int32type) = `int32Max`

##### MIN

> **MIN**: [`Int32Type`](#int32type) = `int32Min`

##### ONE

> **ONE**: [`Int32Type`](#int32type) = `int32One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int32

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int32 to its bigint value.

###### Parameters

###### value

[`Int32Type`](#int32type)

The Int32 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int32 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int32Type`](#int32type)

The Int32 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int32 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int32Type`](#int32type)

The Int32 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int32Type`](#int32type) = `int32Zero`

***

### Int64

> `const` **Int64**: (`value`) => [`Int64Type`](#int64type) & `object`

Defined in: [primitives/Int64/Int64.ts:17](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int64/Int64.ts#L17)

Utility functions for Int64 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int64 values are equal

###### Parameters

###### a

[`Int64Type`](#int64type)

###### b

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int64Type`](#int64type)

Create an Int64 from various input types.

###### Parameters

###### value

[`Int64Input`](#int64input)

The value to convert (bigint, number, or string)

###### Returns

[`Int64Type`](#int64type)

A branded Int64Type

###### Throws

Int64RangeError if value is outside [MIN, MAX]

###### Throws

Int64ParseError if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int64Type`](#int64type)

Decode a Felt252 back to an Int64.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int64Type`](#int64type)

The signed Int64 value

###### Throws

Int64RangeError if the decoded value is outside Int64 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int64 is negative (< 0)

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int64 is positive (> 0)

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int64 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int64 is zero

###### Parameters

###### value

[`Int64Type`](#int64type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int64Type`](#int64type) = `int64Max`

##### MIN

> **MIN**: [`Int64Type`](#int64type) = `int64Min`

##### ONE

> **ONE**: [`Int64Type`](#int64type) = `int64One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int64

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int64 to its bigint value.

###### Parameters

###### value

[`Int64Type`](#int64type)

The Int64 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int64 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int64Type`](#int64type)

The Int64 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int64 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int64Type`](#int64type)

The Int64 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int64Type`](#int64type) = `int64Zero`

***

### Int8

> `const` **Int8**: (`value`) => [`Int8Type`](#int8type) & `object`

Defined in: [primitives/Int8/Int8.ts:17](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Int8/Int8.ts#L17)

Utility functions for Int8 signed integers.

#### Type Declaration

##### equals()

> **equals**: (`a`, `b`) => `boolean`

Check if two Int8 values are equal

###### Parameters

###### a

[`Int8Type`](#int8type)

###### b

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### from()

> **from**: (`value`) => [`Int8Type`](#int8type)

Create an Int8 from various input types.

###### Parameters

###### value

[`Int8Input`](#int8input)

The value to convert (bigint, number, or string)

###### Returns

[`Int8Type`](#int8type)

A branded Int8Type

###### Throws

Int8RangeError if value is outside [MIN, MAX]

###### Throws

Int8ParseError if string cannot be parsed

##### fromFelt()

> **fromFelt**: (`felt`) => [`Int8Type`](#int8type)

Decode a Felt252 back to an Int8.

CRITICAL: This reverses Cairo's field encoding.

Cairo encodes negative values as PRIME + negative_value.
To decode:
- If value <= MAX, it's positive (or zero)
- If value > MAX, it's a negative number: actual = value - PRIME

###### Parameters

###### felt

[`Felt252Type`](#felt252type)

The Felt252 to decode

###### Returns

[`Int8Type`](#int8type)

The signed Int8 value

###### Throws

Int8RangeError if the decoded value is outside Int8 range

##### isNegative()

> **isNegative**: (`value`) => `boolean`

Check if an Int8 is negative (< 0)

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### isPositive()

> **isPositive**: (`value`) => `boolean`

Check if an Int8 is positive (> 0)

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### isValid()

> **isValid**: (`value`) => `boolean`

Check if an Int8 is valid (always true for properly constructed values)

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### isZero()

> **isZero**: (`value`) => `boolean`

Check if an Int8 is zero

###### Parameters

###### value

[`Int8Type`](#int8type)

###### Returns

`boolean`

##### MAX

> **MAX**: [`Int8Type`](#int8type) = `int8Max`

##### MIN

> **MIN**: [`Int8Type`](#int8type) = `int8Min`

##### ONE

> **ONE**: [`Int8Type`](#int8type) = `int8One`

##### PRIME

> **PRIME**: `bigint`

Stark curve field prime: P = 2^251 + 17*2^192 + 1
Used for Cairo field encoding of negative values.

##### SIZE

> **SIZE**: `number`

Bit size of Int8

##### toBigInt()

> **toBigInt**: (`value`) => `bigint`

Convert an Int8 to its bigint value.

###### Parameters

###### value

[`Int8Type`](#int8type)

The Int8 to convert

###### Returns

`bigint`

The signed bigint value

##### toFelt()

> **toFelt**: (`value`) => [`Felt252Type`](#felt252type)

Convert an Int8 to a Felt252 using Cairo field encoding.

CRITICAL: Cairo signed integer encoding is NOT two's complement!

Cairo uses prime field arithmetic:
- Positive values: stored directly (0 to MAX)
- Negative values: stored as PRIME + negative_value

This is because in modular arithmetic over the field,
PRIME + x === x (mod PRIME), so PRIME - 1 represents -1.

###### Parameters

###### value

[`Int8Type`](#int8type)

The Int8 to convert

###### Returns

[`Felt252Type`](#felt252type)

The Felt252 representation for Cairo

##### toHex()

> **toHex**: (`value`) => `string`

Convert an Int8 to its hexadecimal string representation.

For negative values, returns a string with a minus sign prefix
followed by 0x and the absolute value in hex.

###### Parameters

###### value

[`Int8Type`](#int8type)

The Int8 to convert

###### Returns

`string`

Hexadecimal string (e.g., "0xff" or "-0x1")

##### ZERO

> **ZERO**: [`Int8Type`](#int8type) = `int8Zero`

***

### MAX\_CONTRACT\_ADDRESS

> `const` **MAX\_CONTRACT\_ADDRESS**: `bigint`

Defined in: [primitives/ContractAddress/constants.ts:4](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ContractAddress/constants.ts#L4)

Maximum valid contract address (< 2^251)

***

### MAX\_ETH\_ADDRESS

> `const` **MAX\_ETH\_ADDRESS**: `bigint`

Defined in: [primitives/EthAddress/constants.ts:4](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/EthAddress/constants.ts#L4)

Maximum valid ETH address (< 2^160)

***

### MAX\_SHORT\_STRING\_LENGTH

> `const` **MAX\_SHORT\_STRING\_LENGTH**: `31` = `31`

Defined in: [primitives/Felt252/constants.ts:11](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/Felt252/constants.ts#L11)

Maximum length for short strings (31 characters)
Short strings are ASCII strings that fit in a single felt252

***

### StorageKey

> `const` **StorageKey**: (`felt`) => [`StorageKeyType`](#storagekeytype) & `object`

Defined in: [primitives/StorageKey/StorageKey.ts:3](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/StorageKey/StorageKey.ts#L3)

#### Type Declaration

##### from()

> **from**: (`felt`) => [`StorageKeyType`](#storagekeytype)

Create a StorageKey from Felt252 (with validation)

###### Parameters

###### felt

[`Felt252Input`](#felt252input)

###### Returns

[`StorageKeyType`](#storagekeytype)

## Functions

### decodeShortString()

> **decodeShortString**(`felt`): `string`

Defined in: [primitives/ShortString/decodeShortString.ts:15](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ShortString/decodeShortString.ts#L15)

Decode a short string from felt

#### Parameters

##### felt

Felt value as bigint, hex string, or Felt252

`string` | `bigint` | [`Felt252Type`](#felt252type)

#### Returns

`string`

Decoded ASCII string

#### Example

```ts
decodeShortString(448378203247n) // 'hello'
decodeShortString('0x68656c6c6f') // 'hello'
```

***

### encodeShortString()

> **encodeShortString**(`str`): [`Felt252Type`](#felt252type)

Defined in: [primitives/ShortString/encodeShortString.ts:26](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ShortString/encodeShortString.ts#L26)

Encode a short string to Felt252

Short strings are ASCII strings up to 31 characters that fit in a single felt252.
Each character is encoded as its ASCII value.

#### Parameters

##### str

`string`

ASCII string (max 31 characters)

#### Returns

[`Felt252Type`](#felt252type)

Encoded value as Felt252Type

#### Example

```ts
encodeShortString('hello') // Felt252(448378203247n)
```

***

### encodeShortStringHex()

> **encodeShortStringHex**(`str`): `string`

Defined in: [primitives/ShortString/encodeShortStringHex.ts:9](https://github.com/enitrat/kundera/blob/2127a2a91a73792ff92496a7d93a34f996c09df4/packages/kundera-ts/src/primitives/ShortString/encodeShortStringHex.ts#L9)

Encode a short string to hex

#### Parameters

##### str

`string`

ASCII string (max 31 characters)

#### Returns

`string`

Hex-encoded felt representation (unpadded)

## References

### Address

Re-exports [Address](primitives.mdx#address)

***

### CairoSerde

Re-exports [CairoSerde](serde.mdx#cairoserde)

***

### Class

Re-exports [Class](primitives.mdx#class)

***

### deserializeArray

Re-exports [deserializeArray](serde.mdx#deserializearray-1)

***

### deserializeU256

Re-exports [deserializeU256](serde.mdx#deserializeu256-1)

***

### Felt

Re-exports [Felt](crypto.mdx#felt)

***

### feltAdd

Re-exports [feltAdd](crypto.mdx#feltadd)

***

### feltDiv

Re-exports [feltDiv](crypto.mdx#feltdiv)

***

### feltInverse

Re-exports [feltInverse](crypto.mdx#feltinverse)

***

### feltMul

Re-exports [feltMul](crypto.mdx#feltmul)

***

### feltNeg

Re-exports [feltNeg](crypto.mdx#feltneg)

***

### feltPow

Re-exports [feltPow](crypto.mdx#feltpow)

***

### feltSqrt

Re-exports [feltSqrt](crypto.mdx#feltsqrt)

***

### feltSub

Re-exports [feltSub](crypto.mdx#feltsub)

***

### getPublicKey

Re-exports [getPublicKey](crypto.mdx#getpublickey)

***

### isNativeAvailable

Re-exports [isNativeAvailable](crypto.mdx#isnativeavailable)

***

### isWasmAvailable

Re-exports [isWasmAvailable](crypto.mdx#iswasmavailable)

***

### isWasmLoaded

Re-exports [isWasmLoaded](crypto.mdx#iswasmloaded)

***

### loadWasmCrypto

Re-exports [loadWasmCrypto](crypto.mdx#loadwasmcrypto)

***

### MAX\_ADDRESS

Re-exports [MAX_ADDRESS](primitives.mdx#max_address)

***

### Pedersen

Re-exports [Pedersen](crypto.mdx#pedersen)

***

### pedersenHash

Re-exports [pedersenHash](crypto.mdx#pedersenhash-1)

***

### Poseidon

Re-exports [Poseidon](crypto.mdx#poseidon)

***

### poseidonHash

Re-exports [poseidonHash](crypto.mdx#poseidonhash-1)

***

### poseidonHashMany

Re-exports [poseidonHashMany](crypto.mdx#poseidonhashmany-1)

***

### recover

Re-exports [recover](crypto.mdx#recover)

***

### serializeArray

Re-exports [serializeArray](serde.mdx#serializearray-1)

***

### serializeByteArray

Re-exports [serializeByteArray](serde.mdx#serializebytearray-1)

***

### serializeU256

Re-exports [serializeU256](serde.mdx#serializeu256-1)

***

### sign

Re-exports [sign](crypto.mdx#sign)

***

### Signature

Re-exports [Signature](crypto.mdx#signature)

***

### snKeccak

Re-exports [snKeccak](crypto.mdx#snkeccak)

***

### StarkCurve

Re-exports [StarkCurve](crypto.mdx#starkcurve)

***

### Storage

Re-exports [Storage](primitives.mdx#storage)

***

### Uint128

Re-exports [Uint128](primitives/Uint128.mdx#uint128)

***

### Uint16

Re-exports [Uint16](primitives/Uint16.mdx#uint16)

***

### Uint256

Re-exports [Uint256](primitives/Uint256.mdx#uint256)

***

### Uint32

Re-exports [Uint32](primitives/Uint32.mdx#uint32)

***

### Uint64

Re-exports [Uint64](primitives/Uint64.mdx#uint64)

***

### Uint8

Re-exports [Uint8](primitives/Uint8.mdx#uint8)

***

### verify

Re-exports [verify](crypto.mdx#verify-1)
