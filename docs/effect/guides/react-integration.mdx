---
title: React Integration
description: Use Kundera Effect in React applications
---

# React Integration

Learn how to integrate Kundera Effect services into React applications.

## Setup

Install dependencies:

```bash
npm install @kundera-sn/kundera-effect effect react
```

## Provider Pattern

Create a context provider for Effect services:

```typescript
import { createContext, useContext } from "react"
import { ProviderService, AccountService } from "@kundera-sn/kundera-effect/services"
import { Effect, Layer } from "effect"

// Create service layer
const AppLayer = Layer.mergeAll(
  ProviderService.layer({
    url: "https://api.zan.top/public/starknet-sepolia"
  }),
  AccountService.layer({
    address: "0x...",
    privateKey: "0x..."
  })
)

// Create context
const ServiceContext = createContext<typeof AppLayer | null>(null)

// Provider component
export function ServiceProvider({ children }: { children: React.ReactNode }) {
  return (
    <ServiceContext.Provider value={AppLayer}>
      {children}
    </ServiceContext.Provider>
  )
}

// Hook to use services
export function useServices() {
  const layer = useContext(ServiceContext)
  if (!layer) throw new Error("useServices must be used within ServiceProvider")
  return layer
}
```

## Using Services in Components

Create a custom hook for running Effect programs:

```typescript
import { useState, useEffect } from "react"
import { Effect } from "effect"

export function useEffect<A, E>(
  program: Effect.Effect<A, E, any>,
  deps: any[] = []
) {
  const [data, setData] = useState<A | null>(null)
  const [error, setError] = useState<E | null>(null)
  const [loading, setLoading] = useState(true)
  const layer = useServices()

  useEffect(() => {
    setLoading(true)
    setError(null)

    Effect.runPromise(
      program.pipe(
        Effect.provide(layer),
        Effect.either
      )
    ).then(result => {
      if (result._tag === "Left") {
        setError(result.left)
      } else {
        setData(result.right)
      }
      setLoading(false)
    })
  }, deps)

  return { data, error, loading }
}
```

## Example Component

Use the hook in your components:

```typescript
import { ProviderService } from "@kundera-sn/kundera-effect/services"
import { Effect } from "effect"

function BlockNumber() {
  const { data, error, loading } = useEffect(
    Effect.gen(function* () {
      const provider = yield* ProviderService
      return yield* provider.getBlockNumber()
    })
  )

  if (loading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return <div>Latest block: {data?.toString()}</div>
}

export function App() {
  return (
    <ServiceProvider>
      <BlockNumber />
    </ServiceProvider>
  )
}
```

## Wallet Connection

Integrate with wallet providers:

```typescript
import { useAccount, useConnectors } from "@starknet-react/core"

function WalletConnect() {
  const { address } = useAccount()
  const { connect, connectors } = useConnectors()

  // Create dynamic layer based on connected wallet
  const WalletLayer = useMemo(() => {
    if (!address) return null

    return AccountService.layer({
      address: address,
      // Use wallet signer instead of private key
      signer: walletSigner
    })
  }, [address])

  return (
    <button onClick={() => connect({ connector: connectors[0] })}>
      {address ? `Connected: ${address}` : "Connect Wallet"}
    </button>
  )
}
```

## Real-Time Updates

Subscribe to blockchain events:

```typescript
import { ProviderService } from "@kundera-sn/kundera-effect/services"
import { Stream } from "effect"

function BlockStream() {
  const [blocks, setBlocks] = useState<bigint[]>([])
  const layer = useServices()

  useEffect(() => {
    const subscription = Effect.runPromise(
      ProviderService.subscribeToBlocks().pipe(
        Stream.take(10),
        Stream.tap(block => Effect.sync(() => {
          setBlocks(prev => [...prev, block.block_number])
        })),
        Stream.runDrain,
        Effect.provide(layer)
      )
    )

    return () => subscription.then(s => s.interrupt())
  }, [])

  return (
    <div>
      <h3>Latest Blocks:</h3>
      {blocks.map(num => <div key={num.toString()}>{num.toString()}</div>)}
    </div>
  )
}
```

## Error Boundaries

Wrap Effect errors in React error boundaries:

```typescript
import { Component, ErrorInfo, ReactNode } from "react"

class EffectErrorBoundary extends Component<
  { children: ReactNode },
  { error: Error | null }
> {
  state = { error: null }

  static getDerivedStateFromError(error: Error) {
    return { error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Effect error:", error, errorInfo)
  }

  render() {
    if (this.state.error) {
      return (
        <div>
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error.message}</pre>
          </details>
        </div>
      )
    }

    return this.props.children
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Services" icon="server" href="/effect/services/provider">
    Explore available services
  </Card>

  <Card title="Testing" icon="flask" href="/effect/guides/testing">
    Test React components
  </Card>

  <Card title="Error Handling" icon="shield" href="/effect/guides/error-handling">
    Handle errors properly
  </Card>

  <Card title="Examples" icon="code" href="https://github.com/enitrat/kundera/tree/main/examples">
    Browse React examples
  </Card>
</CardGroup>
