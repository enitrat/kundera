---
title: Effect Primitives
description: Type-safe Starknet primitives with Effect error handling
---

# Effect Primitives

Type-safe, validated Starknet primitives that prevent common bugs at compile time.

## Why Branded Types?

Starknet uses 252-bit field elements for everything—addresses, class hashes, storage keys. They're all the same size, but **mixing them is a bug**.

### Without Branded Types (Dangerous)

```typescript
// Both are just strings—easy to mix up
const address = '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7';
const classHash = '0x052c7f38c1b29c15bdb4e7f6d6e2d6e4e5f6e7f8e9f0f1f2f3f4f5f6f7f8f9fa';

// No compile-time error, runtime bug!
deployContract(address, classHash); // Oops, wrong order!
```

### With Kundera (Safe)

```typescript
import { Effect } from "effect";
import * as ContractAddress from "@kundera-sn/kundera-effect/primitives/ContractAddress";
import * as ClassHash from "@kundera-sn/kundera-effect/primitives/ClassHash";

const program = Effect.gen(function* () {
  const address = yield* ContractAddress.from(
    '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7'
  );
  const classHash = yield* ClassHash.from(
    '0x052c7f38c1b29c15bdb4e7f6d6e2d6e4e5f6e7f8e9f0f1f2f3f4f5f6f7f8f9fa'
  );

  // TypeScript catches this at compile time
  deployContract(address, classHash);
  //             ~~~~~~~ Type error: expected ClassHash, got ContractAddress
});
```

**Benefits:**
- ✅ Compile-time type safety
- ✅ Runtime validation
- ✅ Zero runtime cost (types erased after compilation)
- ✅ Descriptive error messages

## Available Primitives

| Primitive | Range/Constraint | Use Case |
|-----------|------------------|----------|
| **Felt252** | 0 to 2^252 - 1 | Generic field elements, calldata |
| **ContractAddress** | 0 to 2^251 - 1 | Contract addresses |
| **ClassHash** | 0 to 2^252 - 1 | Contract class identifiers |
| **StorageKey** | 0 to 2^252 - 1 | Storage slot keys |
| **EthAddress** | 20 bytes | Ethereum addresses (bridging) |
| **ShortString** | Max 31 ASCII chars | Cairo short strings |

## Basic Usage

All primitive constructors return `Effect<T, PrimitiveError>` for type-safe error handling:

```typescript
import { Effect } from 'effect';
import * as Felt252 from '@kundera-sn/kundera-effect/primitives/Felt252';
import * as ContractAddress from '@kundera-sn/kundera-effect/primitives/ContractAddress';

const program = Effect.gen(function* () {
  // Parse from hex strings
  const felt = yield* Felt252.from('0x123');
  const address = yield* ContractAddress.from(
    '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7'
  );

  // Pure functions don't need Effect
  const hex = Felt252.toHex(felt);
  const bigint = Felt252.toBigInt(felt);
  const isZero = Felt252.isZero(felt);

  return { felt, address, hex, bigint };
});

await Effect.runPromise(program);
```

## Parsing with Error Handling

Handle invalid inputs gracefully:

```typescript
import { Effect } from "effect";
import * as ContractAddress from "@kundera-sn/kundera-effect/primitives/ContractAddress";

const parseAddress = (input: string) =>
  ContractAddress.from(input).pipe(
    Effect.catchTag('PrimitiveError', (error) => {
      console.error(`Invalid address: ${error.message}`);
      console.error(`Input: ${error.input}`);
      console.error(`Expected: ${error.expected}`);

      // Return a fallback value
      return Effect.succeed(ContractAddress.ZERO);
    })
  );

// Usage
const address = await Effect.runPromise(parseAddress("0xINVALID"));
// Logs error details, returns zero address
```

**Error metadata available:**
- `message` - Human-readable description
- `operation` - Which operation failed (e.g., "ContractAddress.from")
- `input` - The invalid input value
- `expected` - What format was expected
- `cause` - Underlying error (if any)

## Common Patterns

### Validate Before Use

```typescript
import * as ContractAddress from "@kundera-sn/kundera-effect/primitives/ContractAddress";

// Quick validation without Effect
if (ContractAddress.isValid(userInput)) {
  const address = await Effect.runPromise(ContractAddress.from(userInput));
  // Safe to use
}
```

### Multiple Primitives

```typescript
const program = Effect.gen(function* () {
  const [address, classHash, storageKey] = yield* Effect.all([
    ContractAddress.from('0x123...'),
    ClassHash.from('0x456...'),
    StorageKey.from('0x789...')
  ]);

  return { address, classHash, storageKey };
});
```

### Convert Between Formats

```typescript
const program = Effect.gen(function* () {
  const felt = yield* Felt252.from('0x123abc');

  // Convert to different formats
  const hex = Felt252.toHex(felt);        // "0x123abc"
  const bigint = Felt252.toBigInt(felt);  // 1194684n
  const bytes = Felt252.toBytes(felt);    // Uint8Array(32)

  return { hex, bigint, bytes };
});
```

## Working with Contracts

Primitives integrate seamlessly with contract calls:

```typescript
import { Effect } from "effect";
import * as ContractAddress from "@kundera-sn/kundera-effect/primitives/ContractAddress";
import { Services } from "@kundera-sn/kundera-effect";

const ERC20_ABI = [...] as const;

const ContractsLayer = Services.Contract.makeContractRegistry({
  USDC: {
    abi: ERC20_ABI,
    address: "0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8"
  }
});

const getBalance = (userAddress: string) =>
  Effect.gen(function* () {
    // Parse address with validation
    const address = yield* ContractAddress.from(userAddress);

    // Use in contract call
    const { USDC } = yield* Services.Contract.ContractRegistryService;
    const balance = yield* USDC.read.balanceOf(address);

    return balance;
  });

// Handle both parse errors and RPC errors
const balance = await Effect.runPromise(
  getBalance("0x...").pipe(
    Effect.catchTags({
      PrimitiveError: (e) => {
        console.error("Invalid address format");
        return Effect.succeed(0n);
      },
      RpcError: (e) => {
        console.error("Contract call failed");
        return Effect.succeed(0n);
      }
    }),
    Effect.provide(ContractsLayer),
    Effect.provide(Services.Contract.ContractLayer),
    Effect.provide(ProviderLayer)
  )
);
```

## Quick Reference

### Felt252

```typescript
import * as Felt252 from '@kundera-sn/kundera-effect/primitives/Felt252';

// Constructors
yield* Felt252.from(value);           // string | bigint | number | Uint8Array
yield* Felt252.fromHex('0x123');      // hex string
yield* Felt252.fromBigInt(123n);      // bigint
yield* Felt252.fromBytes(bytes);      // 32-byte Uint8Array

// Conversions
Felt252.toHex(felt);                  // "0x..."
Felt252.toBigInt(felt);               // bigint
Felt252.toBytes(felt);                // Uint8Array(32)

// Utilities
Felt252.isZero(felt);                 // boolean
Felt252.equals(a, b);                 // boolean

// Constants
Felt252.ZERO;                         // 0n
Felt252.ONE;                          // 1n
Felt252.FIELD_PRIME;                  // 2^251 + 17 * 2^192 + 1
```

### ContractAddress

```typescript
import * as ContractAddress from '@kundera-sn/kundera-effect/primitives/ContractAddress';

// Constructors
yield* ContractAddress.from('0x...');

// Validation
ContractAddress.isValid(value);       // boolean

// Constants
ContractAddress.ZERO;                 // Zero address
ContractAddress.MAX_CONTRACT_ADDRESS; // 2^251 - 1
```

### ClassHash

```typescript
import * as ClassHash from '@kundera-sn/kundera-effect/primitives/ClassHash';

yield* ClassHash.from('0x...');
ClassHash.isValid(value);
```

### StorageKey

```typescript
import * as StorageKey from '@kundera-sn/kundera-effect/primitives/StorageKey';

yield* StorageKey.from('0x...');
StorageKey.isValid(value);
```

### EthAddress

```typescript
import * as EthAddress from '@kundera-sn/kundera-effect/primitives/EthAddress';

yield* EthAddress.from('0xd8da6bf26964af9d7eed9e03e53415d37aa96045');
EthAddress.isValid(value);
```

### ShortString

```typescript
import * as ShortString from '@kundera-sn/kundera-effect/primitives/ShortString';

yield* ShortString.from('hello');     // max 31 ASCII chars
ShortString.isValid(value);
```

## Troubleshooting

### "Value exceeds maximum"

Your input is too large for the primitive type:

```typescript
// Error: Felt252 max is 2^252 - 1
yield* Felt252.from(2n ** 253n);

// Error: ContractAddress max is 2^251 - 1
yield* ContractAddress.from(2n ** 252n);
```

**Fix:** Ensure your value is within the valid range for the primitive type.

### "Invalid hex string"

Your hex string is malformed:

```typescript
// Missing 0x prefix
yield* Felt252.from("123abc");

// Invalid characters
yield* Felt252.from("0xGGG");
```

**Fix:** Use proper hex format with `0x` prefix and valid hex characters (0-9, a-f).

### "Expected 20 bytes, got X"

EthAddress must be exactly 20 bytes:

```typescript
// Too short
yield* EthAddress.from("0x123");

// Too long
yield* EthAddress.from("0x" + "a".repeat(50));
```

**Fix:** Ethereum addresses are exactly 40 hex characters (20 bytes).

### "String too long"

ShortString has a 31 character limit:

```typescript
yield* ShortString.from("This string is way too long for a Cairo short string");
```

**Fix:** Keep strings under 31 ASCII characters, or use a different encoding method.

## Type Safety in Action

The type system prevents common mistakes:

```typescript
import { Effect } from "effect";
import * as ContractAddress from "@kundera-sn/kundera-effect/primitives/ContractAddress";
import * as ClassHash from "@kundera-sn/kundera-effect/primitives/ClassHash";

declare function deployContract(
  classHash: ClassHash.ClassHashType,
  address: ContractAddress.ContractAddressType
): Effect.Effect<void, never, never>;

const program = Effect.gen(function* () {
  const address = yield* ContractAddress.from("0x123...");
  const classHash = yield* ClassHash.from("0x456...");

  // ✅ Correct
  yield* deployContract(classHash, address);

  // ❌ TypeScript error - parameters swapped
  yield* deployContract(address, classHash);
  //                     ~~~~~~~ Type 'ContractAddressType' is not assignable to type 'ClassHashType'
});
```

This compile-time safety catches bugs before they reach production.

## Next Steps

<CardGroup cols={2}>
  <Card title="Felt252 Details" icon="cube" href="/effect/primitives/felt252">
    Deep dive into Felt252 operations
  </Card>
  <Card title="ContractAddress" icon="location-dot" href="/effect/primitives/contract-address">
    Contract address specifics
  </Card>
  <Card title="Error Handling" icon="shield-halved" href="/effect/guides/error-handling">
    Master PrimitiveError handling
  </Card>
  <Card title="Getting Started" icon="rocket" href="/getting-started/quickstart">
    See primitives in context
  </Card>
</CardGroup>
