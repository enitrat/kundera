---
title: Effect Crypto
description: Cryptographic operations with Effect error handling
---

# Effect Crypto

Type-safe cryptographic operations for Starknet—hashing, signing, and verification with explicit error handling.

## Why Effect Crypto?

Cryptographic operations can fail (invalid keys, backend unavailable, etc.). Effect tracks these failures in the type system:

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';

// Type: Effect<bigint, CryptoError, never>
//                ^^^^^^ Success   ^^^^^^^^^^^^ Error      ^^^^^ No dependencies
const hash = Crypto.pedersenHash(a, b);
```

**Benefits:**
- TypeScript knows operations can fail
- Must handle `CryptoError` explicitly
- No silent failures or exceptions

<Note>
Kundera uses **native Rust crypto** (fastest) when available, falling back to **WASM** (portable), then **pure TypeScript** (slowest). The backend is selected automatically based on your environment.
</Note>

## Hash Functions

### Pedersen Hash

The standard Starknet hash function:

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';
import * as Felt252 from '@kundera-sn/kundera-effect/primitives/Felt252';

const program = Effect.gen(function* () {
  const a = yield* Felt252.from("0x123");
  const b = yield* Felt252.from("0x456");

  // Hash two felts
  const hash = yield* Crypto.pedersenHash(a, b);

  return Felt252.toHex(hash);
});

await Effect.runPromise(program);
// "0x..." (deterministic hash)
```

**Use for:**
- Storage key derivation
- Merkle tree construction
- General-purpose hashing

### Poseidon Hash

Optimized hash for Starknet VM:

```typescript
const program = Effect.gen(function* () {
  const values = yield* Effect.all([
    Felt252.from("0x1"),
    Felt252.from("0x2"),
    Felt252.from("0x3"),
  ]);

  // Hash multiple values
  const hash = yield* Crypto.poseidonHashMany(values);

  return Felt252.toHex(hash);
});
```

**Use for:**
- More efficient than Pedersen in Cairo
- Batch hashing multiple values
- On-chain hash verification

### Starknet Keccak

Starknet's version of keccak256:

```typescript
const program = Effect.gen(function* () {
  // Hash a string (ASCII)
  const hash = yield* Crypto.snKeccak("transfer");

  return Felt252.toHex(hash);
});

// Used for function selectors and event keys
```

## Signatures

### Signing Messages

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';
import * as Felt252 from '@kundera-sn/kundera-effect/primitives/Felt252';

const signMessage = (privateKeyHex: string, messageHex: string) =>
  Effect.gen(function* () {
    const privateKey = yield* Felt252.from(privateKeyHex);
    const messageHash = yield* Felt252.from(messageHex);

    // Sign the message
    const signature = yield* Crypto.sign(privateKey, messageHash);

    return {
      r: Felt252.toHex(signature.r),
      s: Felt252.toHex(signature.s),
    };
  });

// Usage
const sig = await Effect.runPromise(
  signMessage(
    "0x1234567890abcdef...",
    "0xdeadbeef..."
  )
);
```

### Verifying Signatures

```typescript
const verifySignature = (
  publicKeyHex: string,
  messageHex: string,
  rHex: string,
  sHex: string
) =>
  Effect.gen(function* () {
    const [publicKey, messageHash, r, s] = yield* Effect.all([
      Felt252.from(publicKeyHex),
      Felt252.from(messageHex),
      Felt252.from(rHex),
      Felt252.from(sHex),
    ]);

    // Verify the signature
    const isValid = yield* Crypto.verify(
      publicKey,
      messageHash,
      { r, s }
    );

    return isValid;
  });

// Usage
const valid = await Effect.runPromise(
  verifySignature(pubKey, msg, sig.r, sig.s)
);
```

### Deriving Public Keys

```typescript
const getPublicKey = (privateKeyHex: string) =>
  Effect.gen(function* () {
    const privateKey = yield* Felt252.from(privateKeyHex);

    // Derive public key from private key
    const publicKey = yield* Crypto.getPublicKey(privateKey);

    return Felt252.toHex(publicKey);
  });
```

## Transaction Hashing

### Invoke Transaction (V3)

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';
import * as ContractAddress from '@kundera-sn/kundera-effect/primitives/ContractAddress';

const computeInvokeHash = (
  senderAddress: string,
  calldata: bigint[],
  chainId: string
) =>
  Effect.gen(function* () {
    const sender = yield* ContractAddress.from(senderAddress);

    const txHash = yield* Crypto.computeInvokeV3Hash(
      {
        senderAddress: sender,
        calldata,
        chainId,
        nonce: 0n,
        resourceBounds: {
          l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
          l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
        },
        tip: 0n,
        paymasterData: [],
        accountDeploymentData: [],
        nonceDataAvailabilityMode: 0,
        feeDataAvailabilityMode: 0,
      },
      {
        version: 3n,
      }
    );

    return txHash;
  });
```

### Declare Transaction (V3)

```typescript
const computeDeclareHash = (
  senderAddress: string,
  classHash: string,
  compiledClassHash: string,
  chainId: string
) =>
  Effect.gen(function* () {
    const [sender, clsHash, compiledHash] = yield* Effect.all([
      ContractAddress.from(senderAddress),
      ClassHash.from(classHash),
      ClassHash.from(compiledClassHash),
    ]);

    const txHash = yield* Crypto.computeDeclareV3Hash(
      {
        senderAddress: sender,
        classHash: clsHash,
        compiledClassHash: compiledHash,
        chainId,
        nonce: 0n,
        resourceBounds: {
          l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
          l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
        },
        tip: 0n,
        paymasterData: [],
        accountDeploymentData: [],
        nonceDataAvailabilityMode: 0,
        feeDataAvailabilityMode: 0,
      },
      {
        version: 3n,
      }
    );

    return txHash;
  });
```

### Deploy Account Transaction (V3)

```typescript
const computeDeployAccountHash = (
  classHash: string,
  constructorCalldata: bigint[],
  contractAddressSalt: bigint,
  chainId: string
) =>
  Effect.gen(function* () {
    const clsHash = yield* ClassHash.from(classHash);

    const txHash = yield* Crypto.computeDeployAccountV3Hash(
      {
        classHash: clsHash,
        constructorCalldata,
        contractAddressSalt,
        chainId,
        nonce: 0n,
        resourceBounds: {
          l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
          l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
        },
        tip: 0n,
        paymasterData: [],
        nonceDataAvailabilityMode: 0,
        feeDataAvailabilityMode: 0,
      },
      {
        version: 3n,
      }
    );

    return txHash;
  });
```

## Contract Address Computation

Predict a contract's address before deployment:

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';
import * as ClassHash from '@kundera-sn/kundera-effect/primitives/ClassHash';
import * as ContractAddress from '@kundera-sn/kundera-effect/primitives/ContractAddress';

const predictContractAddress = (
  classHashHex: string,
  constructorCalldata: bigint[],
  salt: bigint,
  deployerAddressHex: string
) =>
  Effect.gen(function* () {
    const [clsHash, deployerAddress] = yield* Effect.all([
      ClassHash.from(classHashHex),
      ContractAddress.from(deployerAddressHex),
    ]);

    const address = yield* Crypto.computeContractAddress(
      salt,
      clsHash,
      constructorCalldata,
      deployerAddress
    );

    return ContractAddress.toHex(address);
  });

// Usage
const predictedAddress = await Effect.runPromise(
  predictContractAddress(
    "0x...", // class hash
    [1n, 2n, 3n], // constructor args
    123n, // salt
    "0x..." // deployer
  )
);
```

## Field Arithmetic

Perform arithmetic modulo the Starknet field prime:

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';
import * as Felt252 from '@kundera-sn/kundera-effect/primitives/Felt252';

const program = Effect.gen(function* () {
  const a = yield* Felt252.from("0x123");
  const b = yield* Felt252.from("0x456");

  // Field arithmetic (mod FIELD_PRIME)
  const sum = yield* Crypto.feltAdd(a, b);
  const diff = yield* Crypto.feltSub(a, b);
  const prod = yield* Crypto.feltMul(a, b);
  const quot = yield* Crypto.feltDiv(a, b);

  return {
    sum: Felt252.toHex(sum),
    diff: Felt252.toHex(diff),
    prod: Felt252.toHex(prod),
    quot: Felt252.toHex(quot),
  };
});
```

**Use for:**
- Implementing Cairo VM logic in TypeScript
- Computing proofs or challenges
- Custom cryptographic protocols

## Alternative API (Namespaced)

```typescript
import { Effect } from 'effect';
import * as Crypto from '@kundera-sn/kundera-effect/crypto';

const program = Effect.gen(function* () {
  // Namespaced API
  const pedersenHash = yield* Crypto.Pedersen.hash(a, b);
  const poseidonHash = yield* Crypto.Poseidon.hash(a, b);
  const sum = yield* Crypto.Felt.add(a, b);
  const signature = yield* Crypto.StarkCurve.sign(privateKey, hash);

  return { pedersenHash, poseidonHash, sum, signature };
});
```

Both APIs are equivalent—use whichever you prefer.

## Error Handling

Handle cryptographic errors gracefully:

```typescript
const program = Effect.gen(function* () {
  const privateKey = yield* Felt252.from("0x...");
  const message = yield* Felt252.from("0x...");

  const signature = yield* Crypto.sign(privateKey, message);

  return signature;
}).pipe(
  Effect.catchTag("CryptoError", (error) => {
    console.error("Crypto operation failed:", error.message);
    console.error("Operation:", error.operation);

    // Return fallback or fail gracefully
    return Effect.fail(new Error("Signing failed"));
  })
);
```

**CryptoError causes:**
- Invalid private/public key
- Backend unavailable (no native, WASM, or TS backend)
- Invalid signature format
- Arithmetic overflow

## Performance Considerations

Kundera automatically selects the fastest available crypto backend:

| Backend | Speed | Availability |
|---------|-------|--------------|
| **Native (Rust FFI)** | Fastest (10-100x) | Node.js, Bun |
| **WASM** | Fast (2-10x) | All environments |
| **Pure TypeScript** | Baseline (1x) | Fallback |

**Optimization tips:**
- Batch operations when possible (use `poseidonHashMany` instead of multiple `poseidonHash` calls)
- Reuse derived public keys instead of recomputing
- Consider caching frequently-used hashes

## Common Use Cases

### Storage Key Derivation

```typescript
const getStorageKey = (variableName: string, index: bigint) =>
  Effect.gen(function* () {
    // Hash variable name to get base key
    const baseKey = yield* Crypto.snKeccak(variableName);

    // Add index via Pedersen hash
    const indexFelt = yield* Felt252.from(index);
    const storageKey = yield* Crypto.pedersenHash(baseKey, indexFelt);

    return Felt252.toHex(storageKey);
  });
```

### Message Signing for Authentication

```typescript
const authenticateUser = (privateKeyHex: string, challenge: string) =>
  Effect.gen(function* () {
    const privateKey = yield* Felt252.from(privateKeyHex);
    const challengeHash = yield* Crypto.snKeccak(challenge);

    const signature = yield* Crypto.sign(privateKey, challengeHash);

    return {
      challenge,
      r: Felt252.toHex(signature.r),
      s: Felt252.toHex(signature.s),
    };
  });
```

### Merkle Tree Construction

```typescript
const buildMerkleTree = (leaves: bigint[]) =>
  Effect.gen(function* () {
    let currentLevel = leaves;

    while (currentLevel.length > 1) {
      const nextLevel: bigint[] = [];

      for (let i = 0; i < currentLevel.length; i += 2) {
        const left = currentLevel[i];
        const right = currentLevel[i + 1] || left; // Duplicate if odd

        const parent = yield* Crypto.pedersenHash(left, right);
        nextLevel.push(parent);
      }

      currentLevel = nextLevel;
    }

    return currentLevel[0]; // Merkle root
  });
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Primitives" icon="cube" href="/effect/primitives">
    Use felts with crypto operations
  </Card>
  <Card title="ABI Encoding" icon="code" href="/effect/modules/abi">
    Encode data for transactions
  </Card>
  <Card title="Signer Service" icon="signature" href="/effect/services/signer">
    Sign transactions with accounts
  </Card>
  <Card title="Error Handling" icon="shield-halved" href="/effect/guides/error-handling">
    Handle CryptoError gracefully
  </Card>
</CardGroup>
