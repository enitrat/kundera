---
title: Effect Services
description: Complete guide to Kundera Effect services and layer composition
---

# Effect Services

Services provide capabilities your Effect programs need. Layers provide those services with concrete implementations.

This guide shows you how to use each service with practical examples.

## Quick Reference

| Service | Purpose | Key Features |
|---------|---------|--------------|
| **ProviderService** | RPC communication | HTTP/WebSocket, retry, timeout |
| **ContractRegistryService** | Pre-configured contracts | Type-safe methods, centralized config |
| **ContractService** | Ad-hoc contract calls | Read-only operations |
| **ContractWriteService** | Write operations | With signer integration |
| **AccountService** | Account abstraction | OpenZeppelin + ArgentX |
| **SignerService** | Transaction signing | Invoke, declare, deploy |
| **FeeEstimatorService** | Fee estimation | L1/L2 resource bounds |
| **NonceManagerService** | Nonce tracking | Prevents race conditions |
| **RpcBatchService** | Request batching | Optimize network calls |

## ProviderService

The foundation—handles all RPC communication with the network.

### Basic Setup

```typescript
import { Effect } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

// Create a provider layer
const ProviderLayer = Services.Presets.createHttpProvider(
  "https://starknet-sepolia.public.blastapi.io"
);

// Use it in your program
const program = Effect.gen(function* () {
  const provider = yield* Services.Provider.ProviderService;

  const blockNumber = yield* provider.request({
    method: "starknet_blockNumber",
    params: []
  });

  return blockNumber;
}).pipe(Effect.provide(ProviderLayer));

await Effect.runPromise(program);
```

### With Configuration

```typescript
const ProviderLayer = Services.Presets.createHttpProvider(
  "https://starknet-sepolia.public.blastapi.io",
  undefined,  // Optional HTTP headers
  {
    timeoutMs: 30_000,
    retry: {
      maxRetries: 5,
      delayMs: 500
    },
    rateLimit: {
      maxRequests: 20,
      intervalMs: 1000
    }
  }
);
```

**Configuration options:**
- `timeoutMs` - Request timeout (default: 10000)
- `retry.maxRetries` - Max retry attempts
- `retry.delayMs` - Delay between retries
- `rateLimit.maxRequests` - Max requests per interval
- `rateLimit.intervalMs` - Rate limit window

### WebSocket Provider

For real-time updates and subscriptions:

```typescript
const WSProviderLayer = Services.Presets.createWebSocketProvider(
  "wss://starknet-sepolia.public.blastapi.io"
);

const program = Effect.gen(function* () {
  const provider = yield* Services.Provider.ProviderService;

  // Subscribe to new blocks
  const stream = yield* provider.subscribeToBlocks();

  yield* stream.pipe(
    Stream.take(10),  // Take 10 blocks
    Stream.tap((block) => Effect.log(`Block: ${block.block_number}`)),
    Stream.runDrain
  );
}).pipe(Effect.provide(WSProviderLayer));
```

## ContractRegistryService (Recommended)

The **recommended** way to work with contracts—define them once, use everywhere.

### Basic Usage

```typescript
import { Effect } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

// Define ERC-20 ABI
const ERC20_ABI = [
  {
    type: "function",
    name: "balanceOf",
    inputs: [{ name: "account", type: "core::starknet::contract_address::ContractAddress" }],
    outputs: [{ type: "core::integer::u256" }],
    state_mutability: "view",
  },
  {
    type: "function",
    name: "transfer",
    inputs: [
      { name: "recipient", type: "core::starknet::contract_address::ContractAddress" },
      { name: "amount", type: "core::integer::u256" }
    ],
    outputs: [{ type: "core::bool" }],
    state_mutability: "external",
  },
] as const;

// Create registry
const ContractsLayer = Services.Contract.makeContractRegistry({
  ETH: {
    abi: ERC20_ABI,
    address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7"
  },
  STRK: {
    abi: ERC20_ABI,
    address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d"
  }
});

// Use in program
const program = Effect.gen(function* () {
  const { ETH, STRK } = yield* Services.Contract.ContractRegistryService;

  const ethBalance = yield* ETH.read.balanceOf(
    "0x0000000000000000000000000000000000000000000000000000000000000001"
  );

  const strkBalance = yield* STRK.read.balanceOf(
    "0x0000000000000000000000000000000000000000000000000000000000000001"
  );

  return { ethBalance, strkBalance };
}).pipe(
  Effect.provide(ContractsLayer),
  Effect.provide(Services.Contract.ContractLayer),
  Effect.provide(ProviderLayer)
);

const balances = await Effect.runPromise(program);
console.log(balances);
```

### Factory Pattern

For contracts where address isn't known at layer-creation time:

```typescript
const ContractsLayer = Services.Contract.makeContractRegistry({
  // Factory - no address
  ERC20: {
    abi: ERC20_ABI
  }
});

const program = Effect.gen(function* () {
  const { ERC20 } = yield* Services.Contract.ContractRegistryService;

  // Create instance with runtime address
  const token = ERC20.at("0x...dynamic-address...");

  const balance = yield* token.read.balanceOf(userAddress);
  return balance;
});
```

### Why This Pattern?

✅ **Centralized**: Define contracts once
✅ **Type-safe**: Methods inferred from ABI
✅ **Clean**: No inline contract creation cluttering Effect.gen
✅ **Flexible**: Mix pre-addressed and factory patterns

See the [ContractRegistry guide](/effect/services/contract-registry) for advanced usage.

## ContractService

For ad-hoc contract calls without pre-configuration:

```typescript
const program = Effect.gen(function* () {
  const contract = yield* Services.Contract.ContractService;

  const result = yield* contract.read({
    address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
    entrypoint: "balanceOf",
    calldata: ["0x...user-address..."]
  });

  return result;
}).pipe(
  Effect.provide(Services.Contract.ContractLayer),
  Effect.provide(ProviderLayer)
);
```

**When to use:**
- One-off contract calls
- Dynamic contract discovery
- Prototyping

**Prefer ContractRegistryService for production code.**

## AccountService

Provides account abstraction for signing transactions.

### OpenZeppelin Account

Standard account implementation:

```typescript
const AccountLayer = Services.Account.OpenZeppelinAccount({
  address: "0x...your-account-address...",
  privateKey: "0x...your-private-key..."
});

const program = Effect.gen(function* () {
  const account = yield* Services.Account.AccountService;

  const publicKey = yield* account.getPublicKey();
  const nonce = yield* account.getNonce();

  return { publicKey, nonce };
}).pipe(
  Effect.provide(AccountLayer),
  Effect.provide(ProviderLayer)
);
```

### ArgentX Account

For ArgentX wallet support with guardian signatures:

```typescript
const AccountLayer = Services.Account.ArgentXAccount({
  address: "0x...argentx-account...",
  privateKey: "0x...owner-key...",
  guardianPrivateKey: "0x...guardian-key..." // Optional
});
```

<Warning>
Never commit private keys to version control. Use environment variables or secure key management.
</Warning>

## SignerService

Signs and submits transactions.

### Basic Invoke

```typescript
const program = Effect.gen(function* () {
  const signer = yield* Services.Signer.SignerService;

  const tx = yield* signer.invoke({
    calls: [
      {
        contractAddress: "0x...token-address...",
        entrypoint: "transfer",
        calldata: [
          "0x...recipient...",
          1000n,  // amount low
          0n      // amount high
        ]
      }
    ],
    resourceBounds: {
      l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
      l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n }
    }
  });

  yield* Effect.log(`Transaction: ${tx.transaction_hash}`);
  return tx;
}).pipe(
  Effect.provide(Services.Signer.Signer),
  Effect.provide(AccountLayer),
  Effect.provide(ProviderLayer)
);
```

### Multiple Calls in One Transaction

```typescript
const tx = yield* signer.invoke({
  calls: [
    {
      contractAddress: tokenAddress,
      entrypoint: "approve",
      calldata: [spenderAddress, maxU256Low, maxU256High]
    },
    {
      contractAddress: spenderAddress,
      entrypoint: "swapExactTokensForTokens",
      calldata: [amountIn, amountOutMin, pathLen, ...path, to, deadline]
    }
  ],
  resourceBounds: {
    l1_gas: { max_amount: 2_000_000n, max_price_per_unit: 1n },
    l2_gas: { max_amount: 2_000_000n, max_price_per_unit: 1n }
  }
});
```

## FeeEstimatorService

Estimate fees and derive resource bounds:

```typescript
const program = Effect.gen(function* () {
  const estimator = yield* Services.FeeEstimator.FeeEstimatorService;

  const estimate = yield* estimator.estimateFee({
    calls: [
      {
        contractAddress: tokenAddress,
        entrypoint: "transfer",
        calldata: [recipient, amount, 0n]
      }
    ]
  });

  yield* Effect.log(`Estimated gas: ${estimate.gas_consumed}`);
  yield* Effect.log(`Fee: ${estimate.overall_fee}`);

  return estimate;
}).pipe(
  Effect.provide(Services.FeeEstimator.FeeEstimator),
  Effect.provide(AccountLayer),
  Effect.provide(ProviderLayer)
);
```

**Use this to:**
- Show users expected transaction costs
- Set appropriate resource bounds
- Validate transactions before submission

## NonceManagerService

Prevents nonce races when submitting concurrent transactions:

```typescript
const program = Effect.gen(function* () {
  const signer = yield* Services.Signer.SignerService;

  // These can run concurrently without nonce conflicts
  const results = yield* Effect.all([
    signer.invoke({ calls: [call1], resourceBounds }),
    signer.invoke({ calls: [call2], resourceBounds }),
    signer.invoke({ calls: [call3], resourceBounds })
  ]);

  return results;
}).pipe(
  Effect.provide(Services.NonceManager.DefaultNonceManager),
  Effect.provide(Services.Signer.Signer),
  Effect.provide(AccountLayer),
  Effect.provide(ProviderLayer)
);
```

**How it works:**
- Tracks nonces locally
- Queues concurrent transactions
- Submits in correct order
- Prevents nonce collisions

## RpcBatchService

Batch multiple RPC calls into a single HTTP request:

```typescript
const program = Effect.gen(function* () {
  const batch = yield* Services.RpcBatch.RpcBatchService;

  // These are batched automatically
  const [chainId, blockNumber, syncStatus] = yield* Effect.all([
    batch.request("starknet_chainId", []),
    batch.request("starknet_blockNumber", []),
    batch.request("starknet_syncing", [])
  ]);

  return { chainId, blockNumber, syncStatus };
}).pipe(
  Effect.provide(
    Services.Presets.createHttpProviderWithBatch(
      "https://starknet-sepolia.public.blastapi.io",
      {
        maxBatchSize: 20,
        maxWaitTime: 10  // milliseconds
      }
    )
  )
);
```

**Configuration:**
- `maxBatchSize` - Max requests per batch (default: 10)
- `maxWaitTime` - Max time to wait for more requests (default: 5ms)

**Benefits:**
- Reduces HTTP round-trips
- Improves performance for multi-call operations
- Transparent to application code

## Layer Composition

Stack layers to build complete environments:

### Production Setup

```typescript
const ProductionLayers = Layer.mergeAll(
  ProviderLayer,
  ContractsLayer,
  Services.Contract.ContractLayer,
  AccountLayer,
  Services.Signer.Signer,
  Services.NonceManager.DefaultNonceManager
);

const program = myOperation.pipe(Effect.provide(ProductionLayers));
```

### Test Setup

```typescript
const TestProviderLayer = Layer.succeed(
  Services.Provider.ProviderService,
  Services.Provider.ProviderService.of({
    request: ({ method }) => {
      if (method === "starknet_blockNumber") {
        return Effect.succeed(123456n);
      }
      return Effect.fail(new Error("Not mocked"));
    }
  })
);

const TestLayers = Layer.mergeAll(
  TestProviderLayer,
  ContractsLayer,
  Services.Contract.ContractLayer
);

const program = myOperation.pipe(Effect.provide(TestLayers));
```

### Environment-Specific

```typescript
const getProviderLayer = () => {
  switch (process.env.NODE_ENV) {
    case "production":
      return Services.Presets.createHttpProvider(
        "https://starknet-mainnet.public.blastapi.io"
      );
    case "test":
      return TestProviderLayer;
    default:
      return Services.Presets.createHttpProvider(
        "https://starknet-sepolia.public.blastapi.io"
      );
  }
};

const program = myOperation.pipe(
  Effect.provide(ContractsLayer),
  Effect.provide(Services.Contract.ContractLayer),
  Effect.provide(getProviderLayer())
);
```

## Common Patterns

### Read Multiple Contracts

```typescript
const program = Effect.gen(function* () {
  const { ETH, STRK, USDC } = yield* Services.Contract.ContractRegistryService;

  const [ethBalance, strkBalance, usdcBalance] = yield* Effect.all([
    ETH.read.balanceOf(userAddress),
    STRK.read.balanceOf(userAddress),
    USDC.read.balanceOf(userAddress)
  ]);

  return { ethBalance, strkBalance, usdcBalance };
});
```

### Approve and Transfer

```typescript
const program = Effect.gen(function* () {
  const { ERC20 } = yield* Services.Contract.ContractRegistryService;
  const signer = yield* Services.Signer.SignerService;

  const token = ERC20.at(tokenAddress);

  // Single transaction with multiple calls
  const tx = yield* signer.invoke({
    calls: [
      {
        contractAddress: token.address,
        entrypoint: "approve",
        calldata: [spenderAddress, amount, 0n]
      },
      {
        contractAddress: spenderAddress,
        entrypoint: "transferFrom",
        calldata: [userAddress, recipientAddress, amount, 0n]
      }
    ],
    resourceBounds: {
      l1_gas: { max_amount: 2_000_000n, max_price_per_unit: 1n },
      l2_gas: { max_amount: 2_000_000n, max_price_per_unit: 1n }
    }
  });

  return tx;
});
```

### Check Balance Before Transfer

```typescript
const transfer = (recipient: string, amount: bigint) =>
  Effect.gen(function* () {
    const { ETH } = yield* Services.Contract.ContractRegistryService;
    const signer = yield* Services.Signer.SignerService;

    // Check balance first
    const balance = yield* ETH.read.balanceOf(signer.address);

    if (balance < amount) {
      return yield* Effect.fail(
        new Error(`Insufficient balance: ${balance} < ${amount}`)
      );
    }

    // Proceed with transfer
    const tx = yield* signer.invoke({
      calls: [{
        contractAddress: ETH.address,
        entrypoint: "transfer",
        calldata: [recipient, amount, 0n]
      }],
      resourceBounds: {
        l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
        l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n }
      }
    });

    return tx;
  });
```

### Subscribe to Events

```typescript
const program = Effect.gen(function* () {
  const provider = yield* Services.Provider.ProviderService;

  const stream = yield* provider.subscribeToEvents({
    address: tokenAddress,
    keys: [[transferEventKey]]
  });

  yield* stream.pipe(
    Stream.tap((event) =>
      Effect.log(`Transfer: ${event.data[0]} -> ${event.data[1]}`)
    ),
    Stream.take(100),
    Stream.runDrain
  );
}).pipe(Effect.provide(WSProviderLayer));
```

## Troubleshooting

### "Service not found in context"

You forgot to provide a required layer:

```typescript
// Error: ProviderService not found
const program = Effect.gen(function* () {
  const provider = yield* Services.Provider.ProviderService;
  // ...
});

// Fix: provide the layer
const fixed = program.pipe(Effect.provide(ProviderLayer));
```

### "Cannot read property 'read' of undefined"

Missing ContractRegistryService or ContractLayer:

```typescript
const program = Effect.gen(function* () {
  const { ETH } = yield* Services.Contract.ContractRegistryService;
  // ...
}).pipe(
  Effect.provide(ContractsLayer),           // ✅
  Effect.provide(Services.Contract.ContractLayer),  // ✅
  Effect.provide(ProviderLayer)
);
```

### Layer Order Matters

Some layers depend on others. General rule:

1. **ProviderLayer** (foundation)
2. **ContractLayer**
3. **ContractsLayer** (registry)
4. **AccountLayer**
5. **SignerService**
6. **NonceManagerService**

```typescript
const program = myOperation.pipe(
  Effect.provide(Services.NonceManager.DefaultNonceManager),
  Effect.provide(Services.Signer.Signer),
  Effect.provide(AccountLayer),
  Effect.provide(ContractsLayer),
  Effect.provide(Services.Contract.ContractLayer),
  Effect.provide(ProviderLayer)  // Bottom layer
);
```

Or use `Layer.mergeAll` (order still matters):

```typescript
const AllLayers = Layer.mergeAll(
  ProviderLayer,
  Services.Contract.ContractLayer,
  ContractsLayer,
  AccountLayer,
  Services.Signer.Signer,
  Services.NonceManager.DefaultNonceManager
);
```

## Next Steps

<CardGroup cols={2}>
  <Card title="ContractRegistry Deep Dive" icon="layer-group" href="/effect/services/contract-registry">
    Master the ContractRegistry pattern
  </Card>
  <Card title="Testing Guide" icon="flask" href="/effect/guides/testing">
    Test your services with dependency injection
  </Card>
  <Card title="Error Handling" icon="shield-halved" href="/effect/guides/error-handling">
    Handle service errors gracefully
  </Card>
  <Card title="Getting Started" icon="rocket" href="/getting-started/quickstart">
    Complete walkthrough with all services
  </Card>
</CardGroup>

## Service Reference

| Service | Import | Layer |
|---------|--------|-------|
| ProviderService | `Services.Provider.ProviderService` | `Services.Presets.createHttpProvider(url)` |
| ContractService | `Services.Contract.ContractService` | `Services.Contract.ContractLayer` |
| ContractRegistryService | `Services.Contract.ContractRegistryService` | `Services.Contract.makeContractRegistry({...})` |
| AccountService | `Services.Account.AccountService` | `Services.Account.OpenZeppelinAccount({...})` |
| SignerService | `Services.Signer.SignerService` | `Services.Signer.Signer` |
| FeeEstimatorService | `Services.FeeEstimator.FeeEstimatorService` | `Services.FeeEstimator.FeeEstimator` |
| NonceManagerService | `Services.NonceManager.NonceManagerService` | `Services.NonceManager.DefaultNonceManager` |
| RpcBatchService | `Services.RpcBatch.RpcBatchService` | `Services.Presets.createHttpProviderWithBatch(url, config)` |
