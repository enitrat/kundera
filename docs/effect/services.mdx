---
title: Effect Services
description: Transport/Provider/RpcBatch services for @kundera-sn/kundera-effect
---

# Effect Services

@kundera-sn/kundera-effect exposes a minimal services layer similar to Voltaireâ€™s DI model.

## What's Included

- `TransportService` + live layers: `HttpTransport`, `WebSocketTransport` (retry/timeout/rate-limit)
- `ProviderService`: typed `request({ method, params })`
- `RawProviderService`: wrap a provider instance for Effect
- `FeeEstimatorService`: estimate fees + derive resource bounds
- `RpcBatchService`: request batching with configurable queueing
- `ContractService`: typed `readContract` + `callRaw`
- `ContractFactory`: typed contract instance (`read`/`write`/`simulate`)
- **`ContractRegistryService`**: pre-configured contracts in a Layer (recommended)
- `ContractWriteService`: write contract calls with a signer
- `AccountService`: OpenZeppelin + ArgentX account signing for `INVOKE_V3`
- `SignerService`: sign + submit invoke transactions
- `NonceManagerService`: local nonce sequencing
- Presets: `createHttpProvider`, `createWebSocketProvider`, `createHttpProviderWithBatch`

## Service Pages

<CardGroup cols={2}>
  <Card title="Contract Registry" icon="layer-group" href="/effect/services/contract-registry">
    Pre-configured contracts in a Layer (recommended).
  </Card>
  <Card title="Provider" icon="plug" href="/effect/services/provider">
    ProviderService, RawProvider, and presets.
  </Card>
  <Card title="Fee Estimator" icon="gauge-high" href="/effect/services/fee-estimator">
    Estimate fees and derive resource bounds.
  </Card>
  <Card title="Contract" icon="file-contract" href="/effect/services/contract">
    Read-only contract calls and typed ContractFactory.
  </Card>
  <Card title="Contract Write" icon="pen" href="/effect/services/contract-write">
    Write contract calls with a signer.
  </Card>
  <Card title="Account" icon="user-shield" href="/effect/services/account">
    Account layers for OpenZeppelin and ArgentX.
  </Card>
  <Card title="ArgentX Account" icon="user-astronaut" href="/effect/services/argentx-account">
    ArgentX signature format and guardian support.
  </Card>
  <Card title="Signer" icon="signature" href="/effect/services/signer">
    Sign + submit invoke transactions.
  </Card>
  <Card title="Nonce Manager" icon="hashtag" href="/effect/services/nonce-manager">
    Local nonce sequencing for concurrent txs.
  </Card>
  <Card title="RPC Batch" icon="layer-group" href="/effect/services/rpc-batch">
    Batch JSON-RPC requests with queueing.
  </Card>
</CardGroup>

## Example

```ts
import { Effect } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

const program = Effect.gen(function* () {
  const provider = yield* Services.Provider.ProviderService;
  const chainId = yield* provider.request<string>({
    method: "starknet_chainId",
    params: []
  });
  return chainId;
}).pipe(
  Effect.provide(
    Services.Presets.createHttpProvider(
      "https://starknet.example.com",
      undefined,
      {
        timeoutMs: 10_000,
        retry: { maxRetries: 3, delayMs: 200 },
        rateLimit: { maxRequests: 10, intervalMs: 1000 }
      }
    )
  )
);

await Effect.runPromise(program);
```

## Contract Reads (Recommended)

Use `ContractRegistryService` to pre-configure contracts in a Layer:

```ts
import { Effect } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

const ERC20_ABI = [
  {
    type: "function",
    name: "balanceOf",
    inputs: [{ name: "account", type: "core::starknet::contract_address::ContractAddress" }],
    outputs: [{ type: "core::integer::u256" }],
    state_mutability: "view",
  },
] as const;

// Define contracts once in a Layer
const ContractsLayer = Services.Contract.makeContractRegistry({
  ETH: { abi: ERC20_ABI, address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7" },
  STRK: { abi: ERC20_ABI, address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d" },
});

const program = Effect.gen(function* () {
  const { ETH, STRK } = yield* Services.Contract.ContractRegistryService;

  const ethBalance = yield* ETH.read.balanceOf("0x...");
  const strkBalance = yield* STRK.read.balanceOf("0x...");

  return { ethBalance, strkBalance };
}).pipe(
  Effect.provide(ContractsLayer),
  Effect.provide(Services.Contract.ContractLayer),
  Effect.provide(Services.Presets.createHttpProvider("https://starknet.example.com"))
);

await Effect.runPromise(program);
```

<Info>
For low-level contract calls or dynamic addresses, see [ContractService](/effect/services/contract).
</Info>

## Sign Invokes (OpenZeppelin Accounts)

```ts
import { Effect } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

const program = Effect.gen(function* () {
  const signer = yield* Services.Signer.SignerService;

  return yield* signer.invoke({
    calls: [
      {
        contractAddress: "0x...",
        entrypoint: "transfer",
        calldata: [1n, 2n]
      }
    ],
    resourceBounds: {
      l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
      l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n }
    }
  });
}).pipe(
  Effect.provide(Services.Presets.createHttpProvider("https://starknet.example.com")),
  Effect.provide(Services.Account.OpenZeppelinAccount({
    address: "0x...",
    privateKey: "0x..."
  })),
  Effect.provide(Services.Signer.Signer)
);

await Effect.runPromise(program);
```

## Nonce Management

Add `DefaultNonceManager` to avoid nonce races with concurrent transactions.

```ts
const program = Effect.gen(function* () {
  const signer = yield* Services.Signer.SignerService;
  const result = yield* signer.invoke({
    calls: [{ contractAddress: "0x...", entrypoint: "transfer", calldata: [1n] }],
    resourceBounds: {
      l1_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n },
      l2_gas: { max_amount: 1_000_000n, max_price_per_unit: 1n }
    }
  });
  return result;
}).pipe(
  Effect.provide(Services.Presets.createHttpProvider("https://starknet.example.com")),
  Effect.provide(Services.Account.OpenZeppelinAccount({
    address: "0x...",
    privateKey: "0x..."
  })),
  Effect.provide(Services.NonceManager.DefaultNonceManager),
  Effect.provide(Services.Signer.Signer)
);
```

## Batching

```ts
import { Effect } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

const program = Effect.gen(function* () {
  const batch = yield* Services.RpcBatch.RpcBatchService;
  const [chainId, blockNumber] = yield* Effect.all([
    batch.request<string>("starknet_chainId"),
    batch.request<number>("starknet_blockNumber")
  ]);
  return { chainId, blockNumber };
}).pipe(
  Effect.provide(
    Services.Presets.createHttpProviderWithBatch("https://starknet.example.com", {
      maxBatchSize: 20,
      maxWaitTime: 10
    })
  )
);

await Effect.runPromise(program);
```
