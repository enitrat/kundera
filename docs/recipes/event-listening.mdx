---
title: Event Listening
description: Subscribe to contract events in real-time.
---

Listen to contract events using WebSocket subscriptions or polling with HTTP.

## WebSocket Subscriptions

For real-time events, use WebSocket provider:

```typescript
import { WebSocketProvider } from 'kundera/provider';
import { webSocketTransport } from 'kundera/transport';
import { decodeEvents } from 'kundera/abi';

const provider = new WebSocketProvider({
  transport: webSocketTransport({
    url: 'wss://starknet-mainnet.ws.blastapi.io',
  }),
});

// Subscribe to new block headers
for await (const block of provider.subscribeNewHeads()) {
  console.log('New block:', block.block_number);

  // Fetch and decode events from this block
  const receipt = await provider.getBlockWithReceipts(block.block_number);
  // Process events...
}
```

## Poll for Events (HTTP)

Without WebSocket support, poll periodically:

```typescript
import { createHttpProvider } from 'kundera/provider';
import { decodeEvents } from 'kundera/abi';

const provider = createHttpProvider({
  url: 'https://starknet-mainnet.public.blastapi.io',
});

let lastBlock = await provider.getBlockNumber();

async function pollEvents() {
  const currentBlock = await provider.getBlockNumber();

  if (currentBlock > lastBlock) {
    // Get events in new blocks
    const events = await provider.getEvents({
      from_block: { block_number: lastBlock + 1 },
      to_block: { block_number: currentBlock },
      address: contractAddress,
    });

    // Decode events
    for (const event of events.events) {
      const { result } = decodeEvents({ events: [event] }, abi);
      if (result?.length) {
        console.log('Event:', result[0]);
      }
    }

    lastBlock = currentBlock;
  }
}

// Poll every 5 seconds
setInterval(pollEvents, 5000);
```

## Filter Specific Events

Listen for specific event types:

```typescript
import { compileEventFilter } from 'kundera/abi';

// Compile filter for Transfer events to my address
const { result: filter } = compileEventFilter(abi, 'Transfer', {
  to: myAddress,
});

// Use with RPC getEvents
const events = await provider.getEvents({
  from_block: { block_number: startBlock },
  to_block: 'latest',
  address: tokenAddress,
  keys: [
    ['0x' + filter.selector.toString(16)],
    [], // from: any
    ['0x' + myAddress.toString(16)], // to: myAddress
  ],
});
```

## Decode Events from Transaction

After a transaction, decode its events:

```typescript
const { result } = await contract.write('transfer', [recipient, amount]);

// Poll for receipt
let receipt;
do {
  const { result: r } = await client.starknet_getTransactionReceipt(result.transactionHash);
  receipt = r;
  if (!receipt || receipt.finality_status === 'RECEIVED') {
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
} while (!receipt || receipt.finality_status === 'RECEIVED');

// Decode all events
const { result: events } = decodeEvents(receipt, abi);

for (const event of events) {
  console.log(`${event.name}:`, event.args);
}
```

## Watch for Specific Contract Events

Create a reusable event watcher:

```typescript
async function watchEvents(
  provider: Provider,
  contractAddress: string,
  abi: Abi,
  eventName: string,
  callback: (event: DecodedReceiptEvent) => void
) {
  let lastBlock = await provider.getBlockNumber();

  const poll = async () => {
    try {
      const currentBlock = await provider.getBlockNumber();

      if (currentBlock > lastBlock) {
        const { events } = await provider.getEvents({
          from_block: { block_number: lastBlock + 1 },
          to_block: { block_number: currentBlock },
          address: contractAddress,
        });

        const { result: decoded } = decodeEvents(
          { events },
          abi,
          { event: eventName }
        );

        decoded?.forEach(callback);
        lastBlock = currentBlock;
      }
    } catch (error) {
      console.error('Poll error:', error);
    }
  };

  const interval = setInterval(poll, 5000);
  return () => clearInterval(interval);
}

// Usage
const stopWatching = await watchEvents(
  provider,
  tokenAddress,
  ERC20_ABI,
  'Transfer',
  (event) => {
    console.log('Transfer:', event.args.from, '->', event.args.to, event.args.value);
  }
);

// Later: stop watching
stopWatching();
```

## Handle Pagination

Large event ranges need pagination:

```typescript
async function getAllEvents(
  provider: Provider,
  contractAddress: string,
  fromBlock: number,
  toBlock: number
) {
  const allEvents = [];
  let continuationToken: string | undefined;

  do {
    const result = await provider.getEvents({
      from_block: { block_number: fromBlock },
      to_block: { block_number: toBlock },
      address: contractAddress,
      chunk_size: 1000,
      continuation_token: continuationToken,
    });

    allEvents.push(...result.events);
    continuationToken = result.continuation_token;
  } while (continuationToken);

  return allEvents;
}
```

## React Hook Pattern

For React applications:

```typescript
function useContractEvents(
  provider: Provider,
  contractAddress: string,
  abi: Abi,
  eventName: string
) {
  const [events, setEvents] = useState<DecodedReceiptEvent[]>([]);

  useEffect(() => {
    let lastBlock: number;
    let mounted = true;

    const init = async () => {
      lastBlock = await provider.getBlockNumber();
    };

    const poll = async () => {
      if (!mounted) return;

      const currentBlock = await provider.getBlockNumber();
      if (currentBlock > lastBlock) {
        const { events: raw } = await provider.getEvents({
          from_block: { block_number: lastBlock + 1 },
          to_block: { block_number: currentBlock },
          address: contractAddress,
        });

        const { result } = decodeEvents({ events: raw }, abi, { event: eventName });
        if (result?.length) {
          setEvents(prev => [...prev, ...result]);
        }
        lastBlock = currentBlock;
      }
    };

    init().then(() => {
      const interval = setInterval(poll, 5000);
      return () => {
        mounted = false;
        clearInterval(interval);
      };
    });
  }, [provider, contractAddress, eventName]);

  return events;
}
```

<Warning>
## Rate Limits

Be mindful of RPC rate limits when polling. Use reasonable intervals (5+ seconds) and batch requests when possible.
</Warning>

## Related

<CardGroup cols={2}>
  <Card title="Events Guide" icon="bell" href="/guides/abi/events">
    Event decoding guide.
  </Card>
  <Card title="Event Filtering" icon="filter" href="/concepts/event-filtering">
    Understanding event keys.
  </Card>
</CardGroup>
