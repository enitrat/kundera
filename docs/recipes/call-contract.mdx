---
title: Call Contract
description: Read data and execute functions on any Starknet contract.
---

Interact with any Starknet contract using `getContract` or direct account execution.

## Read Contract State

Call view functions without gas:

```typescript
import { createClient } from 'kundera/rpc';
import { getContract } from 'kundera/contract';

const client = createClient({
  url: 'https://starknet-mainnet.public.blastapi.io',
});

const contract = getContract({
  abi: CONTRACT_ABI,
  address: contractAddress,
  client,
});

// Read balance
const { result, error } = await contract.read('balance_of', [accountAddress]);

if (!error) {
  console.log('Balance:', result[0]);
}
```

## Write to Contract

State-changing calls require an account:

```typescript
import { createAccount, createSigner } from 'kundera/account';

const signer = createSigner(process.env.PRIVATE_KEY!);
const account = createAccount(client, accountAddress, signer);

const contract = getContract({
  abi: CONTRACT_ABI,
  address: contractAddress,
  client,
  account, // Required for writes
});

const { result, error } = await contract.write('set_value', [42n]);

if (!error) {
  console.log('TX:', result.transactionHash);
}
```

## Multiple Calls (Multicall)

Execute multiple calls atomically:

```typescript
// Prepare calls
const call1 = contract.populate('approve', [spender, amount]);
const call2 = contract.populate('stake', [amount]);

// Execute atomically
const { transaction_hash } = await account.execute([
  call1.result!,
  call2.result!,
]);
```

<Tip>
Multicall is atomicâ€”all calls succeed or all revert. Use it for multi-step operations like approve + swap.
</Tip>

## Direct Account Execute

For full control, use account.execute directly:

```typescript
const { transaction_hash } = await account.execute([
  {
    contractAddress: tokenAddress,
    entrypoint: 'transfer',
    calldata: [recipient, amountLow, amountHigh],
  },
]);
```

## Raw Provider Call

For maximum flexibility, call the provider directly:

```typescript
const result = await provider.call({
  contract_address: contractAddress,
  entry_point_selector: '0x...', // Function selector
  calldata: ['0x123', '0x456'],
});
```

## Decode Results

Contract results are decoded automatically:

```typescript
// Automatic decoding with getContract
const { result } = await contract.read('get_data', []);
// result is already decoded: [value1, value2, ...]

// Manual decoding from raw call
import { decodeOutput } from 'kundera/abi';
const { result: decoded } = decodeOutput(abi, 'get_data', rawResult);
```

## Handle Complex Types

### Structs

```typescript
// Read struct
const { result } = await contract.read('get_position', []);
// result[0] = { x: bigint, y: bigint }

// Write struct
await contract.write('set_position', [{ x: 10n, y: 20n }]);
```

### Arrays

```typescript
// Read array
const { result } = await contract.read('get_values', []);
// result[0] = [bigint, bigint, ...]

// Write array
await contract.write('process_values', [[1n, 2n, 3n]]);
```

### Enums

```typescript
// Read enum
const { result } = await contract.read('get_status', []);
// result[0] = { variant: 'Active', value: null }

// Write enum
await contract.write('set_status', [
  { variant: 'Pending', value: 42n },
]);
```

## Error Handling

All operations return `{ result, error }`:

```typescript
const { result, error } = await contract.write('risky_function', []);

if (error) {
  switch (error.code) {
    case 'ACCOUNT_REQUIRED':
      console.error('Need an account for writes');
      break;
    case 'ENCODE_ERROR':
      console.error('Invalid arguments:', error.message);
      break;
    default:
      console.error('Call failed:', error.message);
  }
  return;
}

console.log('Success:', result);
```

## Wait for Transaction

Wait for transaction confirmation:

```typescript
const { result } = await contract.write('transfer', [recipient, amount]);

// Poll for confirmation
let receipt;
do {
  const { result: r } = await client.starknet_getTransactionReceipt(result.transactionHash);
  receipt = r;
  if (!receipt || receipt.finality_status === 'RECEIVED') {
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
} while (!receipt || receipt.finality_status === 'RECEIVED');

console.log('Status:', receipt.finality_status);
```

## Get Function Selector

Get the selector for direct calls:

```typescript
const { result } = contract.getSelector('transfer');
console.log('Selector:', result.selectorHex);
```

## Related

<CardGroup cols={2}>
  <Card title="Contract API" icon="file-contract" href="/api/contract">
    Full contract API reference.
  </Card>
  <Card title="ABI Encoding" icon="code" href="/guides/abi/encode-decode">
    Manual argument encoding.
  </Card>
</CardGroup>
