---
title: Runtime Implementations
description: Three crypto backends - Pure JS (default), Native FFI, or WASM
---

Kundera provides three crypto backends with **identical APIs**. The same code works with all implementations - choose based on your deployment environment and performance needs.

## Three Crypto Backends

| Backend | Import | Use Case | Loading |
|---------|--------|----------|---------|
| **Pure JS** | Default | Works everywhere | None (sync) |
| **Native FFI** | `@kundera-sn/kundera-ts/native` | Backend services, CLI tools | `ensureLoaded()` |
| **WASM** | `@kundera-sn/kundera-ts/wasm` | Browsers, portable | `ensureLoaded()` |

```typescript
// Pure JS (default) - works immediately, no setup
import { Pedersen, Poseidon, Keccak256 } from '@kundera-sn/kundera-ts/crypto';

const hash = Pedersen.hash(a, b);  // Just works

// Native/WASM - explicit import, async load
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.native';
await Pedersen.ensureLoaded();
const fastHash = Pedersen.hash(a, b);
```

<Note>
The default import uses pure JS implementations from `@noble/hashes` and `@scure/starknet`. These are battle-tested, audited libraries that work synchronously in any environment.
</Note>

## Pure JS (Default)

The default import provides synchronous pure JavaScript implementations. No loading, no setup - just import and use.

```typescript
import {
  Pedersen,
  Poseidon,
  Keccak256,
  pedersenHash,
  poseidonHash,
  snKeccak
} from '@kundera-sn/kundera-ts/crypto';

// Namespace style
const h1 = Pedersen.hash(a, b);
const h2 = Poseidon.hash(a, b);
const h3 = Keccak256.hash(data);

// Function style
const h4 = pedersenHash(a, b);
const h5 = poseidonHash(a, b);
const h6 = snKeccak('transfer'); // Starknet selector
```

**Libraries used:**
- `@noble/hashes` - Keccak256
- `@scure/starknet` - Pedersen, Poseidon

<Tip>
Pure JS is recommended for most use cases. It's fast enough for typical workloads and eliminates async complexity. Only switch to Native/WASM if you've measured a bottleneck.
</Tip>

## Native FFI

Direct bindings to Rust via FFI. Maximum performance for compute-heavy workloads.

### Usage Pattern

```typescript
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.native';

// Load once at startup
await Pedersen.ensureLoaded();

// Now use (throws if not loaded)
const hash = Pedersen.hash(a, b);
```

### Bun

Works out of the box using Bun's built-in FFI:

```typescript
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.native';

await Pedersen.ensureLoaded();
console.log('Native ready');
```

<Tip>
Bun's FFI is the fastest option. If you're building a backend service with heavy crypto load, Bun is recommended.
</Tip>

### Node.js

Requires the `ffi-napi` package:

```bash
npm install ffi-napi
```

<Warning>
## Native Dependencies

`ffi-napi` requires native build tools:

**macOS:**
```bash
xcode-select --install
```

**Linux (Ubuntu/Debian):**
```bash
sudo apt-get install build-essential
```

**Windows:**
```bash
npm install --global windows-build-tools
```
</Warning>

### Library Path

Kundera looks for the native library (`libkundera_crypto.dylib`, `.so`, or `.dll`) in:

1. `KUNDERA_NATIVE_LIB` environment variable
2. Adjacent to the package: `node_modules/@kundera-sn/kundera-ts/native/`
3. System library paths

```bash
export KUNDERA_NATIVE_LIB=/path/to/libkundera_crypto.dylib
```

## WASM

WebAssembly enables fast crypto in browsers and environments without FFI support.

### Usage Pattern

```typescript
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.wasm';

// Load once at startup
await Pedersen.ensureLoaded();

// Now use
const hash = Pedersen.hash(a, b);
```

<Warning>
## Load Before Use

Operations throw if WASM isn't loaded:

```typescript
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.wasm';

// ERROR: throws "WASM not loaded"
const hash = Pedersen.hash(a, b);

// FIX: load first
await Pedersen.ensureLoaded();
const hash = Pedersen.hash(a, b); // Works
```
</Warning>

### Browser Setup

```typescript
// main.ts or app initialization
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.wasm';
import { Poseidon } from '@kundera-sn/kundera-ts/crypto/Poseidon/hash.wasm';

async function init() {
  await Promise.all([
    Pedersen.ensureLoaded(),
    Poseidon.ensureLoaded(),
  ]);
  // Now safe to use
}

init();
```

### With React

```tsx
import { useEffect, useState } from 'react';
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.wasm';

function App() {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    Pedersen.ensureLoaded().then(() => setReady(true));
  }, []);

  if (!ready) return <div>Loading crypto...</div>;
  return <YourApp />;
}
```

### With Next.js

```tsx
'use client';

import { useEffect, useState } from 'react';
import { Pedersen } from '@kundera-sn/kundera-ts/crypto/Pedersen/hash.wasm';

export default function RootLayout({ children }) {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    Pedersen.ensureLoaded().then(() => setReady(true));
  }, []);

  if (!ready) return null;
  return children;
}
```

## Performance Comparison

<Warning>
Performance is nuanced. Native/WASM isn't always faster than Pure JS for all operations.
</Warning>

**Bridging overhead**: Crossing the JS↔WASM or JS↔FFI boundary has constant overhead (~1-10μs). For cheap operations, this overhead can exceed the operation itself.

| Operation | Pure JS | WASM | Native | Notes |
|-----------|---------|------|--------|-------|
| pedersen(a, b) | ~50μs | ~10μs | ~5μs | Heavy computation |
| poseidon(a, b) | ~30μs | ~8μs | ~4μs | Heavy computation |
| keccak256 | ~5μs | ~3μs | ~2μs | Moderate gain |
| hex encode | ~0.5μs | ~0.8μs | ~0.6μs | Bridging overhead dominates |

**When to use Native/WASM:**
- Cryptographic operations in hot paths
- Batch operations (amortizes loading cost)
- Backend services with heavy crypto workload

**When Pure JS is fine:**
- Typical dApp operations (a few hashes per tx)
- Simple operations where bridging overhead dominates
- When simplicity matters more than microseconds

<Tip>
Benchmark your actual workload. Most applications don't need Native/WASM performance.
</Tip>

## Backend Selection Guide

| Environment | Recommended | Why |
|-------------|-------------|-----|
| **Browser dApp** | Pure JS or WASM | Pure JS for simplicity, WASM if perf critical |
| **Bun backend** | Native | Built-in FFI, fastest |
| **Node.js backend** | Native | Best performance with ffi-napi |
| **Next.js SSR** | Pure JS | Simplest, works everywhere |
| **CLI tool** | Pure JS or Native | Pure JS for quick scripts, Native for heavy crypto |

## Related

<CardGroup cols={2}>
  <Card title="Crypto API" icon="lock" href="/typescript/api/crypto">
    Cryptographic function reference
  </Card>
  <Card title="Quick Start" icon="rocket" href="/getting-started/quickstart">
    Get up and running quickly
  </Card>
</CardGroup>
