---
title: Quick Start
description: Get up and running with Kundera in 5 minutes
---

## Installation

```bash
npm install @kundera-sn/kundera-ts
```

Or with other package managers:

```bash
pnpm add @kundera-sn/kundera-ts
yarn add @kundera-sn/kundera-ts
bun add @kundera-sn/kundera-ts
```

## Choose Your Crypto Backend

Kundera needs a crypto backend for signing and hashing. Choose based on your environment:

<Tabs>
  <Tab title="Browser (WASM)">
    Load WASM at app startup:

    ```typescript
    import { loadWasmCrypto } from '@kundera-sn/kundera-ts/wasm';

    // Call once at startup
    await loadWasmCrypto();
    ```
  </Tab>
  <Tab title="Bun (Native)">
    Native crypto works out of the box in Bun:

    ```typescript
    import { isNativeAvailable } from '@kundera-sn/kundera-ts/native';

    console.log(isNativeAvailable()); // true
    ```
  </Tab>
  <Tab title="Node.js (Native)">
    Install the FFI package for best performance:

    ```bash
    npm install koffi
    ```

    Then use normally:

    ```typescript
    import { isNativeAvailable } from '@kundera-sn/kundera-ts/native';

    console.log(isNativeAvailable()); // true if koffi installed
    ```
  </Tab>
</Tabs>

<Note>
**Don't need signing?** If you only need read operations (calling contracts, fetching state), you can skip crypto setup entirely.
</Note>

## Your First Request

Create a provider and query the chain.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';

const provider = new HttpProvider({
  url: 'https://starknet-sepolia.example.com'
});

// Get current block number
const blockNumber = await provider.request(Rpc.BlockNumberRequest());
console.log('Block:', blockNumber);

// Get chain ID
const chainId = await provider.request(Rpc.ChainIdRequest());
console.log('Chain:', chainId);
```

The `Rpc` namespace contains request builders for all 37 Starknet JSON-RPC methods. Each builder constructs a `{ method, params }` object that you pass to `provider.request()`.

## Call a Contract

Read an ERC-20 token balance.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';
import { ContractAddress } from '@kundera-sn/kundera-ts';

const provider = new HttpProvider({
  url: 'https://starknet-sepolia.example.com'
});

// ETH token on Starknet
const ethToken = '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7';
const account = '0x...'; // your account address

// balanceOf selector
const balanceOfSelector = '0x2e4263afad30923c891518314c3c95dbe830a16874e8abc5777a9a20b54c76e';

const result = await provider.request(
  Rpc.CallRequest(
    {
      contract_address: ethToken,
      entry_point_selector: balanceOfSelector,
      calldata: [account]
    },
    'latest'
  )
);

// Result is [low, high] for u256
const low = BigInt(result[0]);
const high = BigInt(result[1]);
const balance = low + (high << 128n);

console.log('Balance:', balance);
```

## Typed Returns

By default, `provider.request()` returns `Promise<unknown>`. For compile-time return type inference, cast to `TypedProvider<StarknetRpcSchema>`.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import type { TypedProvider, StarknetRpcSchema } from '@kundera-sn/kundera-ts/provider';

const provider = new HttpProvider({
  url: 'https://starknet-sepolia.example.com'
}) as TypedProvider<StarknetRpcSchema>;

// TypeScript now infers return types from method strings
const block = await provider.request({
  method: 'starknet_getBlockWithTxHashes',
  params: [{ block_number: 12345 }]
});
// block: BlockWithTxHashes ✓ (inferred, zero runtime cost)
```

This is a compile-time overlay — the cast adds no runtime behavior. See [Architecture](/overview/architecture) for details.

## Use Branded Types

Kundera uses [branded types](/getting-started/branded-types) to prevent mixing incompatible values at compile time.

```typescript
import { ContractAddress, ClassHash, Felt252 } from '@kundera-sn/kundera-ts';

const address = ContractAddress('0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7');
const classHash = ClassHash('0x...');
const felt = Felt252(123n);

// TypeScript catches argument order mistakes
function deployContract(hash: ClassHashType, addr: ContractAddressType) { }
deployContract(address, classHash); // TS Error: wrong order!

// Convert between formats
const hex = felt.toHex();
const bigint = felt.toBigInt();
```

## Encode/Decode Calldata

The ABI module encodes function arguments and decodes return values.

```typescript
import { encodeCalldata, decodeOutputObject } from '@kundera-sn/kundera-ts/abi';

// Encode function arguments
const encoded = encodeCalldata(erc20Abi, 'transfer', [
  recipientAddress,
  { low: amountLow, high: amountHigh }
]);
if (encoded.error) throw encoded.error;

// Decode return values
const decoded = decodeOutputObject(erc20Abi, 'balanceOf', result.map(BigInt));
if (decoded.error) throw decoded.error;
const balance = decoded.result;
```

## What Makes Kundera Different?

Kundera is a low-level primitives library, not a full SDK. It gives you type-safe building blocks and lets you compose them however you want.

| Feature | Kundera | starknet.js |
|---------|---------|-------------|
| **Type Safety** | Branded types prevent mixups | Plain strings |
| **Bundle Size** | Tree-shakeable, import what you use | Monolithic |
| **Performance** | Native Rust or WASM crypto | Pure JS |
| **Philosophy** | Data-first, explicit dependencies | Object-oriented, implicit state |

## Next Steps

<CardGroup cols={2}>
  <Card title="Architecture" icon="sitemap" href="/overview/architecture">
    Understand the layered stack and design philosophy.
  </Card>
  <Card title="Branded Types" icon="tag" href="/getting-started/branded-types">
    How type safety prevents bugs.
  </Card>
  <Card title="Provider Guide" icon="plug" href="/guides/provider/providers">
    Provider patterns and recipes.
  </Card>
  <Card title="JSON-RPC Reference" icon="code" href="/api/jsonrpc">
    All 37 request builders.
  </Card>
  <Card title="Domain Primitives" icon="cube" href="/primitives/domain-primitives">
    Convert wire types to rich types.
  </Card>
  <Card title="Runtime Implementations" icon="bolt" href="/getting-started/runtime-implementations">
    Native vs WASM crypto deep dive.
  </Card>
</CardGroup>
