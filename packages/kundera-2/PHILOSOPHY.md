# Kundera-2 Philosophy

Most Starknet SDKs follow a familiar pattern: they bundle everything into one cohesive package—primitives, abstractions, contract wrappers, account logic, and convenience utilities—all designed to work together seamlessly. This approach has clear advantages: you get a complete solution out of the box, and the library authors can ensure all the pieces fit together properly. But it also comes with costs that become apparent over time.

When abstractions live inside the library, you inherit the library authors' opinions about how contracts should be called, how accounts should be managed, and how transactions should be built. If those opinions match your needs perfectly, everything works well. But the moment your requirements diverge—perhaps you need a custom signing flow, a specialized batching strategy, or an account model the library didn't anticipate—you face an uncomfortable choice: work around the abstraction, fork the library, or wait for upstream changes that may never come.

Kundera-2 takes a different path, one inspired by the Voltaire project's "primitives-first" philosophy. The insight is simple: separate what must be stable from what should be flexible. The library itself provides only foundational primitives—the Cairo types, ABI parsing and encoding, serialization helpers, provider interfaces, and error definitions that any Starknet application needs. These primitives are designed to be stable, minimal, and unopinionated. They do exactly what they claim to do, nothing more.

Everything else—contract factories, typed wrappers, account modules, caching layers, retry logic—exists as reference implementations that you copy into your own codebase. We call these "skills" or "patterns." They demonstrate how to compose the primitives into higher-level functionality, but they belong to you. You can read them, understand them, modify them, and evolve them independently of the core library. When you need behavior the reference implementation doesn't provide, you simply change your copy. No forking, no waiting, no version conflicts.

This separation has a profound effect on how the library evolves. Because the core contains only primitives, it changes rarely and predictably. Breaking changes are exceptional events, not regular occurrences. Your application's stability doesn't depend on whether the library authors decided to refactor their contract wrapper this month. Meanwhile, the patterns in your codebase can move as fast as your product needs. You can experiment, iterate, and customize without any coupling to release cycles you don't control.

The design also embraces strong typing as a core value, not an afterthought. Kundera-2 uses branded types—compile-time tags that prevent you from accidentally passing an address where a class hash is expected, or mixing up a felt with a uint256. These brands exist purely at the type level; at runtime, the values are just bigints or byte arrays. You get the safety benefits of a strict type system without any runtime overhead or serialization complexity.

Type-level ABI inference extends this philosophy to contract interactions. When you have a contract's ABI, the type system can tell you exactly what arguments a function expects and what it returns. Mistakes that would otherwise surface as cryptic RPC errors or silent data corruption become compile-time errors instead. The runtime's job is simply to encode and decode according to the types the compiler has already verified.

By keeping the core vanilla—no framework dependencies, no WASM requirements, no native modules—Kundera-2 remains easy to integrate into any JavaScript or TypeScript environment. It works in Node, Bun, browsers, and edge runtimes without special configuration. Testing is straightforward because there are no complex build steps or platform-specific quirks to navigate.

The question of what belongs in the core versus what should be a pattern follows from these principles naturally. A feature belongs in the core only if it represents a foundational primitive that many different patterns need, if it can be implemented without framework coupling or heavy dependencies, and if it doesn't impose a particular workflow or UX on users. Features that don't meet all three criteria belong in patterns, where they can be customized freely.

This philosophy requires a shift in mindset. Instead of looking for the library to solve your problems, you use the library's primitives to build solutions tailored to your needs. The reference patterns show you how; your codebase owns the result. The tradeoff is real—you write more code upfront—but the payoff is equally real: you understand what your application does, you can change it when requirements shift, and you never find yourself blocked by decisions someone else made in a library you don't control.

Kundera-2 provides the foundation. What you build on it is yours.
