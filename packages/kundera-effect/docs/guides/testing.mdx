---
title: Testing
description: Mock services with TestTransport and TestProvider â€” no HTTP mocking needed.
---

# Testing with kundera-effect

Effect's dependency injection makes testing straightforward: swap real layers with test layers. No HTTP mocking, no monkey-patching, no global state.

## Setup

Install `@effect/vitest` for Effect-native test helpers:

```bash
pnpm add -D @effect/vitest
```

## TestTransport

`TestTransport` returns canned responses by RPC method name:

```typescript
import { describe, expect, it } from "@effect/vitest";
import { Effect } from "effect";
import { JsonRpc } from "@kundera-sn/kundera-effect";
import { TestTransport } from "@kundera-sn/kundera-effect/testing";
import { ProviderLive } from "@kundera-sn/kundera-effect/services";
import { Layer } from "effect";

const testLayer = ProviderLive.pipe(
  Layer.provide(TestTransport({
    starknet_blockNumber: 42,
    starknet_chainId: "0x534e5f5345504f4c4941",
  }))
);

describe("JsonRpc", () => {
  it.effect("returns mock block number", () =>
    Effect.gen(function* () {
      const blockNum = yield* JsonRpc.blockNumber();
      expect(blockNum).toBe(42);
    }).pipe(Effect.provide(testLayer))
  );
});
```

## TestProvider

`TestProvider` is a shorthand that composes `TestTransport` + `ProviderLive`:

```typescript
import { TestProvider } from "@kundera-sn/kundera-effect/testing";

const testLayer = TestProvider({
  starknet_blockNumber: 42,
  starknet_chainId: "0x534e5f5345504f4c4941",
  starknet_getBlockWithTxHashes: {
    block_hash: "0x123",
    block_number: 42,
    // ... rest of block
  },
});

it.effect("fetches block", () =>
  Effect.gen(function* () {
    const block = yield* JsonRpc.getBlockWithTxHashes("latest");
    expect(block.block_number).toBe(42);
  }).pipe(Effect.provide(testLayer))
);
```

## Simulating Errors

Pass `TransportError` or `RpcError` instances to simulate failures:

```typescript
import { TransportError, RpcError } from "@kundera-sn/kundera-effect/errors";
import { TestProvider } from "@kundera-sn/kundera-effect/testing";

const failingLayer = TestProvider({
  starknet_blockNumber: new TransportError({
    operation: "request",
    message: "Connection refused",
  }),
  starknet_chainId: new RpcError({
    method: "starknet_chainId",
    code: -32601,
    message: "Method not found",
  }),
});

it.effect("handles transport error", () =>
  Effect.gen(function* () {
    const result = yield* JsonRpc.blockNumber().pipe(
      Effect.either
    );
    expect(result._tag).toBe("Left");
  }).pipe(Effect.provide(failingLayer))
);
```

## Mocking Services Directly

For higher-level services, use `Layer.succeed` with a partial mock:

### Mock ContractService

```typescript
import { Layer } from "effect";
import { Services } from "@kundera-sn/kundera-effect";

const TestContract = Layer.succeed(Services.ContractService, {
  readContract: ({ functionName }) => {
    if (functionName === "balanceOf") {
      return Effect.succeed(1_000_000n);
    }
    return Effect.fail(new Services.ContractError({
      contractAddress: "0x...",
      functionName,
      stage: "request",
      message: "Unknown function",
    }));
  },
  buildCall: () => Effect.succeed({ contract_address: "0x...", entry_point_selector: "0x...", calldata: [] }),
  callRaw: () => Effect.succeed(["0x1"]),
  simulateContract: () => Effect.die("not implemented in test"),
});
```

### Mock WalletProviderService

```typescript
const TestWallet = Layer.succeed(Services.WalletProviderService, {
  requestAccounts: () => Effect.succeed(["0xUSER_ADDRESS"]),
  execute: (calls) => Effect.succeed({ transaction_hash: "0xTXHASH" }),
  signMessage: () => Effect.succeed(["0xSIG_R", "0xSIG_S"]),
  getChainId: () => Effect.succeed("0x534e5f5345504f4c4941"),
});
```

### Mock NonceManagerService

```typescript
let nonceCounter = 0n;
const TestNonce = Layer.succeed(Services.NonceManagerService, {
  get: () => Effect.succeed(nonceCounter),
  consume: () => Effect.succeed(nonceCounter++),
  reset: () => Effect.sync(() => { nonceCounter = 0n; }),
});
```

## Testing Error Paths

```typescript
import { describe, expect, it } from "@effect/vitest";

describe("error handling", () => {
  it.effect("catches RPC errors", () =>
    Effect.gen(function* () {
      const result = yield* JsonRpc.blockNumber().pipe(
        Effect.catchTag("RpcError", (e) => Effect.succeed(`caught: ${e.code}`))
      );
      expect(result).toBe("caught: -32601");
    }).pipe(
      Effect.provide(TestProvider({
        starknet_blockNumber: new RpcError({
          method: "starknet_blockNumber",
          code: -32601,
          message: "Method not found",
        }),
      }))
    )
  );
});
```

## Integration Tests

For integration tests against a real node (devnet), compose real layers:

```typescript
import { Presets } from "@kundera-sn/kundera-effect";

const IntegrationLayer = Presets.DevnetProvider();

it.effect("reads real block number", () =>
  Effect.gen(function* () {
    const blockNum = yield* JsonRpc.blockNumber();
    expect(blockNum).toBeGreaterThanOrEqual(0);
  }).pipe(Effect.provide(IntegrationLayer)),
  { timeout: 10_000 }
);
```

## Patterns

| What to test | How |
|-------------|-----|
| RPC calls | `TestProvider` with canned responses |
| Error handling | `TestProvider` with `TransportError`/`RpcError` instances |
| Service interactions | `Layer.succeed(ServiceTag, { ... })` |
| Contract reads | Mock `ContractService` with expected return values |
| Wallet flows | Mock `WalletProviderService` |
| Full integration | `Presets.DevnetProvider()` against local devnet |

## Related

<CardGroup cols={2}>
  <Card title="Error Handling" icon="triangle-exclamation" href="/effect/guides/error-handling">
    Error types and handling patterns.
  </Card>
  <Card title="Presets" icon="sliders" href="/effect/modules/presets">
    Pre-composed layers including TestProviderPreset.
  </Card>
</CardGroup>
