---
title: Error Handling
description: Type-safe error handling with Effect — every failure is tracked at compile time.
---

# Error Handling

Every operation in `@kundera-sn/kundera-effect` returns `Effect<A, E, R>` where `E` is tracked at compile time. No hidden exceptions.

## Error Types

All errors use `Data.TaggedError` with a discriminating `_tag` field:

| Error | Tag | When | Key Fields |
|-------|-----|------|------------|
| `TransportError` | `"TransportError"` | Network failure, timeout, connection refused | `operation`, `message`, `cause?` |
| `RpcError` | `"RpcError"` | JSON-RPC error from node | `method`, `code`, `message`, `data?` |
| `WalletError` | `"WalletError"` | Wallet interaction failure | `operation`, `message`, `cause?` |
| `TransactionError` | `"TransactionError"` | Transaction submission/polling failure | `operation`, `message`, `txHash?`, `cause?` |
| `NonceError` | `"NonceError"` | Nonce fetch or reservation failure | `address`, `message`, `cause?` |
| `ContractError` | `"ContractError"` | ABI encode/decode or contract call failure | `contractAddress`, `functionName`, `stage`, `message`, `cause?` |

Import from:

```typescript
import {
  TransportError,
  RpcError,
  WalletError,
  TransactionError,
  NonceError,
  ContractError,
} from "@kundera-sn/kundera-effect/errors";
```

## Catch Specific Errors

Use `Effect.catchTag` to handle one error type. TypeScript removes the handled type from the error channel:

```typescript
import { Effect } from "effect";
import { JsonRpc, Presets } from "@kundera-sn/kundera-effect";

// Effect<number, TransportError | RpcError, ProviderService>
const block = JsonRpc.blockNumber();

// After catchTag: Effect<number, TransportError, ProviderService>
const handled = block.pipe(
  Effect.catchTag("RpcError", (e) => {
    // e.code, e.method, e.message are available
    return Effect.succeed(-1);
  })
);
```

## Catch Multiple Errors

Use `Effect.catchTags` for multiple error types at once:

```typescript
const program = Effect.gen(function* () {
  const contract = yield* Services.ContractService;
  return yield* contract.readContract({
    abi: erc20Abi,
    address: tokenAddress,
    functionName: "balanceOf",
    args: [ownerAddress],
  });
}).pipe(
  Effect.catchTags({
    ContractError: (e) => {
      // e.stage tells you where it failed: "encode" | "request" | "decode"
      return Effect.succeed(0n);
    },
    TransportError: (e) => {
      // Network failure — maybe retry?
      return Effect.fail(new AppError(`Network: ${e.message}`));
    },
  })
);
```

## Handle All Errors at the Boundary

Let errors propagate through your program. Handle them once at the application boundary:

```typescript
// Business logic — errors propagate automatically
const getBalance = (address: string) =>
  Effect.gen(function* () {
    const contract = yield* Services.ContractService;
    return yield* contract.readContract({
      abi: erc20Abi,
      address: tokenAddress,
      functionName: "balanceOf",
      args: [address],
    });
  });

// Application boundary — handle everything
const main = getBalance("0x1234...").pipe(
  Effect.catchAll((error) => {
    // error._tag discriminates the error type
    console.error(`${error._tag}: ${error.message}`);
    return Effect.sync(() => process.exit(1));
  }),
  Effect.provide(Presets.SepoliaProvider()),
  Effect.provide(Services.ContractLive),
);

await Effect.runPromise(main);
```

## Retry Transient Errors

Use `Effect.retry` with `Schedule` for transient failures:

```typescript
import { Effect, Schedule } from "effect";
import { JsonRpc, Presets } from "@kundera-sn/kundera-effect";

// Retry 3 times with exponential backoff
const resilient = JsonRpc.blockNumber().pipe(
  Effect.retry(
    Schedule.exponential("100 millis").pipe(
      Schedule.intersect(Schedule.recurs(3))
    )
  ),
  Effect.provide(Presets.SepoliaProvider())
);

// Retry only on specific errors
const selective = JsonRpc.blockNumber().pipe(
  Effect.retry({
    times: 3,
    while: (e) => e._tag === "TransportError", // Only retry network errors
  }),
  Effect.provide(Presets.SepoliaProvider())
);
```

## Convert to Either

Get `Either<Error, Value>` for explicit error handling without exceptions:

```typescript
import { Effect, Either } from "effect";

const result = await Effect.runPromise(
  JsonRpc.blockNumber().pipe(
    Effect.either,
    Effect.provide(Presets.SepoliaProvider())
  )
);

if (Either.isLeft(result)) {
  const error = result.left; // TransportError | RpcError
} else {
  const blockNum = result.right; // number
}
```

## Exhaustive Handling with Match

Ensure all error cases are handled at compile time:

```typescript
import { Effect, Match } from "effect";
import type { KunderaError } from "@kundera-sn/kundera-effect/errors";

const handleError = Match.type<KunderaError>().pipe(
  Match.tag("TransportError", (e) => `Network: ${e.message}`),
  Match.tag("RpcError", (e) => `RPC ${e.code}: ${e.message}`),
  Match.tag("WalletError", (e) => `Wallet: ${e.message}`),
  Match.tag("TransactionError", (e) => `TX: ${e.message}`),
  Match.tag("NonceError", (e) => `Nonce: ${e.message}`),
  Match.tag("ContractError", (e) => `Contract ${e.stage}: ${e.message}`),
  Match.exhaustive, // TypeScript error if any case is missing
);
```

## RpcError Codes

`RpcError.code` contains a Starknet-specific error code:

| Code | Meaning |
|------|---------|
| `1` | Failed to write transaction |
| `10` | No blocks |
| `20` | Invalid continuation token |
| `24` | Block not found |
| `25` | Invalid transaction index |
| `27` | Class hash not found |
| `28` | Transaction hash not found |
| `29` | Page size too big |
| `31` | Contract not found |
| `40` | Contract error |
| `41` | Transaction execution error |

## Summary

| Pattern | When |
|---------|------|
| `Effect.catchTag("RpcError", ...)` | Handle one specific error |
| `Effect.catchTags({ ... })` | Handle multiple errors |
| `Effect.catchAll(...)` | Handle any error (boundary) |
| `Effect.mapError(...)` | Transform error type |
| `Effect.either` | Convert to `Either` |
| `Effect.retry(Schedule.*)` | Retry transient failures |
| `Match.exhaustive` | Ensure all cases handled |

**Key principle: track errors in types, handle them at the boundary.**
