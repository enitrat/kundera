---
title: React Integration
description: Use kundera-effect services in React applications with Effect runtime management.
---

# React Integration

This guide covers patterns for using `@kundera-sn/kundera-effect` in React applications — managing Effect runtime, wallet connections, and contract reads in a component lifecycle.

## Runtime Management

Create a single Effect runtime at the app level and reuse it across components:

```typescript
import { Effect, Layer, ManagedRuntime } from "effect";
import { Presets } from "@kundera-sn/kundera-effect";

// Create runtime once at app initialization
const AppRuntime = ManagedRuntime.make(Presets.SepoliaProvider());

// Use in components
async function fetchBlockNumber() {
  const runtime = await AppRuntime.runtime();
  return runtime.runPromise(JsonRpc.blockNumber());
}
```

## Hook Pattern: useEffect + runPromise

The simplest pattern — run an Effect in a React `useEffect`:

```typescript
import { useEffect, useState } from "react";
import { Effect } from "effect";
import { JsonRpc, Presets } from "@kundera-sn/kundera-effect";

function BlockNumber() {
  const [blockNum, setBlockNum] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const program = JsonRpc.blockNumber().pipe(
      Effect.provide(Presets.SepoliaProvider())
    );

    Effect.runPromise(program)
      .then(setBlockNum)
      .catch((e) => setError(String(e)));
  }, []);

  if (error) return <div>Error: {error}</div>;
  if (blockNum === null) return <div>Loading...</div>;
  return <div>Block: {blockNum}</div>;
}
```

## Hook Pattern: useCallback for Actions

For user-triggered actions (button clicks, form submissions):

```typescript
import { useCallback, useState } from "react";
import { Effect } from "effect";
import { Services, Presets } from "@kundera-sn/kundera-effect";

function TransferButton({ swo, recipient, amount }) {
  const [txHash, setTxHash] = useState<string | null>(null);
  const [pending, setPending] = useState(false);

  const handleTransfer = useCallback(async () => {
    setPending(true);
    try {
      const program = Effect.gen(function* () {
        const contractWrite = yield* Services.ContractWriteService;
        const result = yield* contractWrite.invoke({
          abi: erc20Abi,
          address: tokenAddress,
          functionName: "transfer",
          args: [recipient, amount],
        });
        return result.transaction_hash;
      }).pipe(
        Effect.provide(Presets.SepoliaWalletStack({ swo }))
      );

      const hash = await Effect.runPromise(program);
      setTxHash(hash);
    } catch (e) {
      console.error(e);
    } finally {
      setPending(false);
    }
  }, [swo, recipient, amount]);

  return (
    <button onClick={handleTransfer} disabled={pending}>
      {pending ? "Sending..." : "Transfer"}
    </button>
  );
}
```

## Wallet Connection Pattern

Manage wallet state with React context:

```typescript
import { createContext, useContext, useState, useCallback } from "react";
import { Effect } from "effect";
import { Services, Presets } from "@kundera-sn/kundera-effect";
import type { StarknetWindowObject } from "@kundera-sn/kundera-ts/provider";

interface WalletState {
  swo: StarknetWindowObject | null;
  address: string | null;
  connect: (swo: StarknetWindowObject) => Promise<void>;
}

const WalletContext = createContext<WalletState>(null!);

export function WalletProvider({ children }) {
  const [swo, setSwo] = useState<StarknetWindowObject | null>(null);
  const [address, setAddress] = useState<string | null>(null);

  const connect = useCallback(async (walletSwo: StarknetWindowObject) => {
    const program = Effect.gen(function* () {
      const wallet = yield* Services.WalletProviderService;
      const accounts = yield* wallet.requestAccounts();
      return accounts[0];
    }).pipe(
      Effect.provide(Services.WalletProviderLive(walletSwo))
    );

    const addr = await Effect.runPromise(program);
    setSwo(walletSwo);
    setAddress(addr);
  }, []);

  return (
    <WalletContext.Provider value={{ swo, address, connect }}>
      {children}
    </WalletContext.Provider>
  );
}

export const useWallet = () => useContext(WalletContext);
```

## Contract Read Hook

A reusable hook for contract reads:

```typescript
import { useEffect, useState } from "react";
import { Effect } from "effect";
import { Services, Presets } from "@kundera-sn/kundera-effect";
import type { Abi } from "@kundera-sn/kundera-ts/abi";

interface UseContractReadOptions {
  abi: Abi;
  address: string;
  functionName: string;
  args: unknown[];
  enabled?: boolean;
}

function useContractRead<T>({ abi, address, functionName, args, enabled = true }: UseContractReadOptions) {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!enabled) return;

    setLoading(true);
    const program = Effect.gen(function* () {
      const contract = yield* Services.ContractService;
      return yield* contract.readContract({ abi, address, functionName, args });
    }).pipe(
      Effect.provide(Presets.MainnetProvider()),
      Effect.provide(Services.ContractLive),
    );

    Effect.runPromise(program)
      .then((result) => setData(result as T))
      .catch((e) => setError(e instanceof Error ? e : new Error(String(e))))
      .finally(() => setLoading(false));
  }, [address, functionName, JSON.stringify(args), enabled]);

  return { data, error, loading };
}

// Usage
function Balance({ owner }) {
  const { data: balance, loading } = useContractRead<bigint>({
    abi: erc20Abi,
    address: TOKEN_ADDRESS,
    functionName: "balanceOf",
    args: [owner],
  });

  if (loading) return <span>...</span>;
  return <span>{balance?.toString()}</span>;
}
```

## Error Boundaries

Handle Effect errors in React error boundaries:

```typescript
import { Effect, Either } from "effect";

// Convert Effect errors to React-friendly format
async function runSafe<A>(effect: Effect.Effect<A, unknown, never>): Promise<Either.Either<unknown, A>> {
  return Effect.runPromise(Effect.either(effect));
}

// In component
const result = await runSafe(
  JsonRpc.blockNumber().pipe(Effect.provide(Presets.SepoliaProvider()))
);

if (Either.isLeft(result)) {
  // Handle error in UI
} else {
  // Use result.right
}
```

## Tips

- **One runtime per app** — don't create a new runtime per component render
- **Layer outside render** — define layers as module-level constants, not inside components
- **Error at boundary** — use `Effect.either` or `Effect.catchAll` before `runPromise`
- **Cleanup** — use `ManagedRuntime.dispose` in cleanup when using scoped resources (WebSocket)

## Related

<CardGroup cols={2}>
  <Card title="Presets" icon="sliders" href="/effect/modules/presets">
    Pre-composed layers for common setups.
  </Card>
  <Card title="Wallet Provider" icon="wallet" href="/effect/services/wallet-provider">
    Wallet integration service.
  </Card>
  <Card title="Error Handling" icon="triangle-exclamation" href="/effect/guides/error-handling">
    Error types and handling patterns.
  </Card>
</CardGroup>
