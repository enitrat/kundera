---
title: Contract Registry
description: Pre-configure named contracts in a Layer for clean Effect composition.
---

# Contract Registry

`makeContractRegistry` creates a Layer that provides pre-configured, type-safe contract instances. This is the recommended pattern for applications with known contracts.

## Imports

```typescript
import { Services } from "@kundera-sn/kundera-effect";
// or
import { makeContractRegistry } from "@kundera-sn/kundera-effect/services";
```

## Define a Registry

```typescript
import { Services, Presets } from "@kundera-sn/kundera-effect";
import { Effect, Layer } from "effect";

const erc20Abi = [...] as const;
const governanceAbi = [...] as const;

const AppContracts = Services.makeContractRegistry({
  usdc: {
    address: "0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8",
    abi: erc20Abi,
  },
  governance: {
    address: "0x001234...",
    abi: governanceAbi,
  },
});
```

## Use in Effects

```typescript
const program = Effect.gen(function* () {
  const contracts = yield* AppContracts;

  // Type-safe: args and return types inferred from ABI
  const balance = yield* contracts.usdc.read.balanceOf(ownerAddress);
  const proposalCount = yield* contracts.governance.read.proposal_count();

  return { balance, proposalCount };
}).pipe(
  Effect.provide(
    Layer.mergeAll(
      Presets.MainnetProvider(),
      Services.ContractLive,
    )
  )
);
```

## Types

```typescript
interface ContractDefinition<TAbi> {
  readonly address: string;
  readonly abi: TAbi;
}

type ContractRegistryConfig = Record<string, ContractDefinition<unknown>>;
```

## Why Registry over Factory?

| Pattern | Use case |
|---------|----------|
| `Contract(address, abi)` | Dynamic addresses, one-off reads |
| `makeContractRegistry({...})` | Known contracts, app-wide Layer, type inference |

The registry is a `Context.Tag` â€” provide it once at the top of your program. Individual contract reads don't need to re-specify address or ABI.

## Testing

Mock the registry by providing a test Layer:

```typescript
import { Layer } from "effect";

const TestContracts = Layer.succeed(AppContracts, {
  usdc: {
    read: {
      balanceOf: () => Effect.succeed(1_000_000n),
    },
  },
  governance: {
    read: {
      proposal_count: () => Effect.succeed(42n),
    },
  },
});
```

## Related

<CardGroup cols={2}>
  <Card title="Contract Service" icon="file-contract" href="/effect/services/contract">
    Underlying service for contract reads.
  </Card>
  <Card title="Contract Write" icon="pen" href="/effect/services/contract-write">
    Write transactions via wallet or account.
  </Card>
</CardGroup>
