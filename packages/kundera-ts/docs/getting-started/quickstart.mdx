---
title: Quick Start
description: Get up and running with Kundera in 5 minutes
---

## Installation

```bash
npm install @kundera-sn/kundera-ts
```

Or with other package managers:

```bash
pnpm add @kundera-sn/kundera-ts
yarn add @kundera-sn/kundera-ts
bun add @kundera-sn/kundera-ts
```

## Choose Your Crypto Backend

Kundera needs a crypto backend for signing and hashing. Choose based on your environment:

<Tabs>
  <Tab title="Browser (WASM)">
    Load WASM at app startup:

    ```typescript
    import { loadWasmCrypto } from '@kundera-sn/kundera-ts/wasm';

    // Call once at startup
    await loadWasmCrypto();
    ```
  </Tab>
  <Tab title="Bun (Native)">
    Native crypto works out of the box in Bun:

    ```typescript
    import { isNativeAvailable } from '@kundera-sn/kundera-ts/native';

    console.log(isNativeAvailable()); // true
    ```
  </Tab>
  <Tab title="Node.js (Native)">
    Install the FFI package for best performance:

    ```bash
    npm install koffi
    ```

    Then use normally:

    ```typescript
    import { isNativeAvailable } from '@kundera-sn/kundera-ts/native';

    console.log(isNativeAvailable()); // true if koffi installed
    ```
  </Tab>
</Tabs>

<Note>
**Don't need signing?** If you only need read operations (calling contracts, fetching state), you can skip crypto setup entirely.
</Note>

## Your First Request

Create a provider and query the chain.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';

const provider = new HttpProvider({
  url: 'https://api.zan.top/public/starknet-sepolia'
});

// Get current block number
const blockNumber = await provider.request(Rpc.BlockNumberRequest());
console.log('Block:', blockNumber);

// Get chain ID
const chainId = await provider.request(Rpc.ChainIdRequest());
console.log('Chain:', chainId);
```

The `Rpc` namespace contains request builders for all 37 Starknet JSON-RPC methods. Each builder constructs a `{ method, params }` object that you pass to `provider.request()`.

## Call a Contract

Read an ERC-20 token balance using the ABI module.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';
import { computeSelectorHex, encodeCalldata, decodeOutput } from '@kundera-sn/kundera-ts/abi';

const provider = new HttpProvider({
  url: 'https://api.zan.top/public/starknet-sepolia'
});

// Minimal ERC-20 ABI (just what we need)
const erc20Abi = [
  {
    type: 'function',
    name: 'balanceOf',
    inputs: [{ name: 'account', type: 'core::starknet::contract_address::ContractAddress' }],
    outputs: [{ type: 'core::integer::u256' }],
    state_mutability: 'view',
  },
];

const ethToken = '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7';
const account = '0x...'; // your account address

// Compute selector from function name (no hardcoded hex)
const selector = computeSelectorHex('balanceOf');

// Encode calldata using ABI
const encoded = encodeCalldata(erc20Abi, 'balanceOf', [BigInt(account)]);
if (encoded.error) throw encoded.error;

const result = await provider.request(
  Rpc.CallRequest(
    {
      contract_address: ethToken,
      entry_point_selector: selector,
      calldata: encoded.result.map(v => '0x' + v.toString(16)),
    },
    'latest'
  )
);

// Decode output using ABI
const decoded = decodeOutput(erc20Abi, 'balanceOf', result.map(BigInt));
if (decoded.error) throw decoded.error;

console.log('Balance:', decoded.result); // bigint
```

## Typed Returns

`provider.request()` infers return types from Rpc request builders — no casts needed.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';

const provider = new HttpProvider({
  url: 'https://api.zan.top/public/starknet-sepolia'
});

// TypeScript infers return types from the builder's method literal
const blockNum = await provider.request(Rpc.BlockNumberRequest());
// blockNum: number ✓

const block = await provider.request(
  Rpc.GetBlockWithTxHashesRequest({ block_number: 12345 })
);
// block: BlockWithTxHashes ✓
```

This is compile-time only — zero runtime cost. See [Architecture](/overview/architecture) for details.

## Use Branded Types

Kundera uses [branded types](/getting-started/branded-types) to prevent mixing incompatible values at compile time.

```typescript
import { ContractAddress, ClassHash, Felt252 } from '@kundera-sn/kundera-ts';

const address = ContractAddress('0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7');
const classHash = ClassHash('0x...');
const felt = Felt252(123n);

// TypeScript catches argument order mistakes
function deployContract(hash: ClassHashType, addr: ContractAddressType) { }
deployContract(address, classHash); // TS Error: wrong order!

// Convert between formats
const hex = felt.toHex();
const bigint = felt.toBigInt();
```

## Encode/Decode Calldata

The ABI module encodes function arguments and decodes return values.

```typescript
import { encodeCalldata, decodeOutputObject } from '@kundera-sn/kundera-ts/abi';

// Encode function arguments
const encoded = encodeCalldata(erc20Abi, 'transfer', [
  recipientAddress,
  { low: amountLow, high: amountHigh }
]);
if (encoded.error) throw encoded.error;

// Decode return values
const decoded = decodeOutputObject(erc20Abi, 'balanceOf', result.map(BigInt));
if (decoded.error) throw decoded.error;
const balance = decoded.result;
```

## What Makes Kundera Different?

Kundera is a low-level primitives library, not a full SDK. It gives you type-safe building blocks and lets you compose them however you want.

| Feature | Kundera | starknet.js |
|---------|---------|-------------|
| **Type Safety** | Branded types prevent mixups | Plain strings |
| **Bundle Size** | Tree-shakeable, import what you use | Monolithic |
| **Performance** | Native Rust or WASM crypto | Pure JS |
| **Philosophy** | Data-first, explicit dependencies | Object-oriented, implicit state |

## Next Steps

<CardGroup cols={2}>
  <Card title="Architecture" icon="sitemap" href="/overview/architecture">
    Understand the layered stack and design philosophy.
  </Card>
  <Card title="Branded Types" icon="tag" href="/getting-started/branded-types">
    How type safety prevents bugs.
  </Card>
  <Card title="Provider Guide" icon="plug" href="/guides/provider/providers">
    Provider patterns and recipes.
  </Card>
  <Card title="JSON-RPC Reference" icon="code" href="/api/jsonrpc">
    All 37 request builders.
  </Card>
  <Card title="Domain Primitives" icon="cube" href="/primitives/domain-primitives">
    Convert wire types to rich types.
  </Card>
  <Card title="Runtime Implementations" icon="bolt" href="/getting-started/runtime-implementations">
    Native vs WASM crypto deep dive.
  </Card>
</CardGroup>
