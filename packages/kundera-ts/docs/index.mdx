---
title: What is Kundera?
description: A fast, type-safe Starknet primitives library for TypeScript.
---

Kundera is a TypeScript library for working with Starknet primitives, cryptography, and JSON-RPC. It provides:

- **Branded types** that catch address/hash mixups at compile time
- **Native crypto** via Rust FFI for faster signing and hashing
- **WASM fallback** for browsers and portable environments
- **Tree-shakeable** modules—import only what you use

```typescript
import { ContractAddress, ClassHash } from '@kundera-sn/kundera-ts';
import { pedersen } from '@kundera-sn/kundera-ts/crypto';
import { starknet_call } from '@kundera-sn/kundera-ts/jsonrpc';

// Type-safe primitives
const address = ContractAddress('0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7');
const classHash = ClassHash('0x...');

// Fast cryptography
const hash = pedersen(a, b);

// Tree-shakeable JSON-RPC
const result = await starknet_call(
  transport,
  { contract_address, entry_point_selector, calldata },
  'latest'
);
```

## Featured: @kundera-sn/kundera-effect

**For production applications, we recommend [@kundera-sn/kundera-effect](/services)** — Effect-TS integration with typed errors, dependency injection, and composable operations.

```typescript
import { Effect } from 'effect';
import * as Abi from '@kundera-sn/kundera-effect/abi';
import * as Rpc from '@kundera-sn/kundera-effect/jsonrpc';

const program = Effect.gen(function* () {
  const calldata = yield* Abi.encodeCalldata(abi, 'transfer', args);
  const result = yield* Rpc.starknet_call(transport, call, 'latest');
  return result;
}).pipe(
  Effect.retry({ times: 3 }),
  Effect.timeout('10 seconds'),
  Effect.catchTag('RpcError', (e) => Effect.succeed(fallback))
);
```

[Get started with @kundera-sn/kundera-effect →](/services)

## Who is Kundera For?

| Use Case | Why Kundera |
|----------|-------------|
| **Backend services** | Native crypto avoids JS overhead |
| **Frontend dApps** | WASM works in any browser |
| **CLI tools** | Small bundle, fast startup |
| **Libraries** | Tree-shakeable, no bloat for consumers |

## Core Modules

<CardGroup cols={2}>
  <Card title="Primitives" icon="cube" href="/api/primitives">
    Felt252, ContractAddress, ClassHash, StorageKey with branded types.
  </Card>
  <Card title="Crypto" icon="lock" href="/api/crypto">
    Pedersen, Poseidon, ECDSA with native and WASM backends.
  </Card>
  <Card title="JSON-RPC" icon="network-wired" href="/api/jsonrpc">
    Tree-shakeable JSON-RPC methods for Starknet.
  </Card>
  <Card title="Provider" icon="plug" href="/api/provider">
    Typed HTTP and WebSocket providers with request builders.
  </Card>
  <Card title="ABI" icon="code" href="/api/abi">
    Encode and decode calldata using contract ABIs.
  </Card>
  <Card title="Serde" icon="arrows-rotate" href="/api/serde">
    Serialize Cairo types to felts and back.
  </Card>
  <Card title="Transport" icon="satellite" href="/api/transport">
    HTTP and WebSocket transports with JSON-RPC batching.
  </Card>
  <Card title="Utils" icon="toolbox" href="/api/utils">
    Batching, polling, retries, timeouts, and rate limiting helpers.
  </Card>
</CardGroup>

## Quick Example

Read an ERC-20 balance:

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Starknet } from '@kundera-sn/kundera-ts/jsonrpc';
import { decodeOutputObject } from '@kundera-sn/kundera-ts/abi';
import { ContractAddress } from '@kundera-sn/kundera-ts';

const provider = new HttpProvider({ url: 'https://api.zan.top/public/starknet-sepolia' });

const call = Starknet.CallRequest(
  {
    contract_address: ContractAddress('0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7'),
    entry_point_selector: 'balanceOf',
    calldata: [accountAddress]
  },
  'latest'
);
const result = await provider.request<string[]>(call);

const decoded = decodeOutputObject(erc20Abi, 'balanceOf', result.map(BigInt));
if (decoded.error) {
  throw decoded.error;
}
const balance = decoded.result;
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/getting-started/quickstart">
    Get up and running in 5 minutes.
  </Card>
  <Card title="Why Kundera?" icon="question" href="/overview/why-kundera">
    See how Kundera compares to alternatives.
  </Card>
  <Card title="Architecture" icon="sitemap" href="/overview/architecture">
    Understand how the modules fit together.
  </Card>
  <Card title="Skills" icon="puzzle-piece" href="/skills/index">
    Copy-paste patterns for common tasks.
  </Card>
</CardGroup>

## Acknowledgments

Kundera's architecture and documentation are heavily inspired by [Voltaire](https://voltaire.tevm.sh), the Ethereum primitives library from the [TEVM](https://tevm.sh) project. We adopted their approach to:

- **Branded types** for compile-time type safety
- **Data-first API design** with tree-shakeable modules
- **Multi-backend crypto** (native, WASM, JS fallback)
- **Documentation patterns** with per-primitive deep dives

If you're building for Ethereum, check out Voltaire. We're grateful to the TEVM team for establishing these patterns.
