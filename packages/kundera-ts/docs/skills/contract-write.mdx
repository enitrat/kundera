---
title: "Contract Write"
description: "State-changing calls using an account executor."
---

The write skill sends state-changing transactions via account invocation. These calls modify blockchain state and require gas fees.

## Quick Start

```bash
cp -r examples/skills/contract-write src/skills/
```

## Basic Usage

```ts
import { httpTransport } from '@kundera-sn/kundera-ts/transport';
import { signRaw, signatureToArray } from '@kundera-sn/kundera-ts/crypto';
import { createAccountInvoker } from './skills/account-invoke';
import { writeContract } from './skills/contract-write';

const transport = httpTransport('https://api.zan.top/public/starknet-sepolia');
const signTransaction = (hash) => signatureToArray(signRaw(PRIVATE_KEY, hash));

const account = createAccountInvoker({ transport, address, signTransaction });

// Transfer tokens
const { result, error } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

if (!error) {
  console.log('Transaction hash:', result.transaction_hash);
}
```

## How It Works

When you call `writeContract`:

1. **Encode** - Arguments are ABI-encoded into Starknet calldata
2. **Estimate** - Fee is estimated via `starknet_estimateFee`
3. **Sign** - Transaction is signed with your account
4. **Send** - `starknet_addInvokeTransaction` is sent to the sequencer
5. **Return** - Transaction hash is returned immediately

```ts
// What happens under the hood:
const { result } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

// Equivalent to:
import { encodeCalldata } from '@kundera-sn/kundera-ts/abi';

const { result: calldata } = encodeCalldata(ERC20_ABI, 'transfer', [recipient, amount]);
const { transaction_hash } = await account.execute({
  contractAddress: tokenAddress,
  entrypoint: 'transfer',
  calldata,
});
```

<Warning>
Write methods return immediately after the transaction is submitted. The transaction may still be pending or could fail during execution.
</Warning>

## Transaction Options

Override fee parameters:

```ts
// With explicit max fee
const { result } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
  maxFee: 1000000000000000n, // 0.001 ETH
});

// With fee multiplier (for fee estimation buffer)
const { result } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
  feeMultiplier: 1.5, // 50% buffer on estimated fee
});

// With explicit nonce
const { result } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
  nonce: 42n,
});
```

## Error Handling

Write calls can fail at submission or execution:

```ts
const { result, error } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

if (error) {
  switch (error.code) {
    case 'FUNCTION_NOT_FOUND':
      console.error('Function does not exist in ABI');
      break;
    case 'ENCODE_ERROR':
      console.error('Failed to encode arguments');
      break;
    case 'FEE_ESTIMATION_FAILED':
      console.error('Transaction would revert:', error.message);
      break;
    case 'TRANSACTION_REJECTED':
      console.error('Transaction rejected by sequencer');
      break;
  }
}
```

Common failures:
- **Insufficient funds** - Not enough ETH/STRK for gas
- **Invalid nonce** - Nonce already used
- **Contract reverts** - Transaction would fail during execution
- **Signature invalid** - Account validation failed

## Waiting for Confirmation

The write method returns immediately. To wait for confirmation:

```ts
import { starknet_getTransactionReceipt } from '@kundera-sn/kundera-ts/rpc';

const { result } = await writeContract({
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

// Poll for receipt
let receipt = null;
while (!receipt) {
  const { result: r } = await starknet_getTransactionReceipt(transport, result.transaction_hash);
  if (r) receipt = r;
  else await new Promise((resolve) => setTimeout(resolve, 1000));
}

// Check status
if (receipt.execution_status === 'SUCCEEDED') {
  console.log('Transaction succeeded');
} else {
  console.log('Transaction reverted:', receipt.revert_reason);
}
```

## Simulating Before Sending

Use fee estimation to simulate the transaction first:

```ts
import { estimateContractFee } from './skills/contract-viem';

try {
  // This will throw if the transaction would revert
  const { result: fee } = await estimateContractFee(transport, {
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: 'transfer',
    args: [recipient, amount],
    account,
  });

  console.log('Estimated fee:', fee.overall_fee);

  // Safe to send
  const { result } = await writeContract({
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: 'transfer',
    args: [recipient, amount],
    account,
    maxFee: fee.overall_fee * 120n / 100n, // 20% buffer
  });
} catch (error) {
  console.error('Transaction would fail:', error);
}
```

## Multicall (Batching Writes)

Execute multiple calls atomically in a single transaction:

```ts
import { encodeCalldata } from '@kundera-sn/kundera-ts/abi';

const { result: calldata1 } = encodeCalldata(ERC20_ABI, 'approve', [spender, amount]);
const { result: calldata2 } = encodeCalldata(ROUTER_ABI, 'swap', [tokenIn, tokenOut, amount]);

// Both calls execute atomically - all succeed or all revert
await account.execute([
  { contractAddress: tokenAddress, entrypoint: 'approve', calldata: calldata1 },
  { contractAddress: routerAddress, entrypoint: 'swap', calldata: calldata2 },
]);
```

<Tip>
Multicall is useful for approve-then-use patterns. Both operations execute in the same transaction, so you don't need to wait for approval confirmation before swapping.
</Tip>

## Related

<CardGroup cols={2}>
  <Card title="Contract Read" icon="eye" href="/typescript/skills/contract-read">
    Read-only contract calls.
  </Card>
  <Card title="Account Invoke" icon="bolt" href="/typescript/skills/account-invoke">
    Low-level account execution.
  </Card>
  <Card title="Fee Estimation" icon="calculator" href="/typescript/skills/fee-estimation">
    Estimate transaction fees before sending.
  </Card>
  <Card title="Event Filtering" icon="filter" href="/typescript/skills/event-filtering">
    Decode events from transaction receipts.
  </Card>
</CardGroup>
