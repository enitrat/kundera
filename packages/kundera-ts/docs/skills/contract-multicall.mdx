---
title: "Contract Multicall"
description: "Batch multiple read calls with requestBatch."
---

Batch read-only calls in a single JSON-RPC request using `transport.requestBatch`. This reduces latency and avoids RPC rate limits when fetching multiple values.

## Quick Start

```bash
cp -r examples/skills/contract-multicall src/skills/
```

## Basic Usage

```ts
import { httpTransport } from '@kundera-sn/kundera-ts/transport';
import { multicallRead } from './skills/contract-multicall';

const transport = httpTransport('https://api.zan.top/public/starknet-sepolia');

const results = await multicallRead(transport, [
  { abi: ERC20_ABI, address: token1, functionName: 'balance_of', args: [account] },
  { abi: ERC20_ABI, address: token2, functionName: 'balance_of', args: [account] },
  { abi: ERC20_ABI, address: token3, functionName: 'balance_of', args: [account] },
]);

// Each result has { result, error }
for (const { result, error } of results) {
  if (!error) {
    console.log('Balance:', result[0]);
  }
}
```

## How It Works

Instead of making N separate RPC calls:

```ts
// Slow: 3 sequential HTTP requests
const balance1 = await readContract(transport, { ... });
const balance2 = await readContract(transport, { ... });
const balance3 = await readContract(transport, { ... });
```

`multicallRead` batches them into a single HTTP request:

```ts
// Fast: 1 HTTP request with 3 JSON-RPC calls
const [balance1, balance2, balance3] = await multicallRead(transport, [
  { ... },
  { ... },
  { ... },
]);
```

This uses JSON-RPC batch requests under the hood:

```json
[
  { "jsonrpc": "2.0", "id": 1, "method": "starknet_call", "params": [...] },
  { "jsonrpc": "2.0", "id": 2, "method": "starknet_call", "params": [...] },
  { "jsonrpc": "2.0", "id": 3, "method": "starknet_call", "params": [...] }
]
```

## Mixed Contracts and Functions

Batch calls to different contracts and functions:

```ts
const results = await multicallRead(transport, [
  // ERC20 balances
  { abi: ERC20_ABI, address: ethAddress, functionName: 'balance_of', args: [account] },
  { abi: ERC20_ABI, address: usdcAddress, functionName: 'balance_of', args: [account] },

  // Token metadata
  { abi: ERC20_ABI, address: ethAddress, functionName: 'name', args: [] },
  { abi: ERC20_ABI, address: ethAddress, functionName: 'symbol', args: [] },
  { abi: ERC20_ABI, address: ethAddress, functionName: 'decimals', args: [] },

  // AMM pair data
  { abi: PAIR_ABI, address: pairAddress, functionName: 'get_reserves', args: [] },
]);

const [ethBalance, usdcBalance, name, symbol, decimals, reserves] = results;
```

## Error Handling

Each call in the batch can succeed or fail independently:

```ts
const results = await multicallRead(transport, [
  { abi: ERC20_ABI, address: validToken, functionName: 'balance_of', args: [account] },
  { abi: ERC20_ABI, address: invalidToken, functionName: 'balance_of', args: [account] },
]);

results.forEach(({ result, error }, index) => {
  if (error) {
    console.error(`Call ${index} failed:`, error.message);
  } else {
    console.log(`Call ${index} result:`, result);
  }
});
```

## Block Parameter

Specify a block for all calls in the batch:

```ts
const results = await multicallRead(transport, [
  { abi: ERC20_ABI, address: token1, functionName: 'balance_of', args: [account] },
  { abi: ERC20_ABI, address: token2, functionName: 'balance_of', args: [account] },
], {
  blockId: { block_number: 123456 },
});
```

## Performance Tips

<Tip>
## Batch Size Limits

Most RPC providers limit batch size (commonly 100 requests). For large batches, split into chunks:

```ts
function chunk<T>(arr: T[], size: number): T[][] {
  return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>
    arr.slice(i * size, i * size + size)
  );
}

const calls = [...]; // 250 calls
const chunks = chunk(calls, 100);
const allResults = await Promise.all(
  chunks.map((chunk) => multicallRead(transport, chunk))
);
const results = allResults.flat();
```
</Tip>

## Comparison: Multicall vs Promise.all

| Approach | HTTP Requests | Latency | Rate Limiting |
|----------|---------------|---------|---------------|
| Sequential `readContract` | N | High | Risk of hitting limits |
| `Promise.all` with `readContract` | N (parallel) | Medium | Higher risk |
| `multicallRead` | 1 | Low | Minimal risk |

## Write Multicall

For batching state-changing calls, use account multicall:

```ts
import { encodeCalldata } from '@kundera-sn/kundera-ts/abi';

// Batch writes are handled by account.execute()
await account.execute([
  { contractAddress: token1, entrypoint: 'transfer', calldata: [...] },
  { contractAddress: token2, entrypoint: 'transfer', calldata: [...] },
]);
```

See [Contract Write](/skills/contract-write) for details on write multicall.

## Related

<CardGroup cols={2}>
  <Card title="Contract Read" icon="eye" href="/skills/contract-read">
    Single read calls.
  </Card>
  <Card title="Contract Write" icon="pen" href="/skills/contract-write">
    State-changing calls with write multicall.
  </Card>
  <Card title="HTTP Transport" icon="network-wired" href="/skills/http-transport">
    Transport with batch support.
  </Card>
</CardGroup>
