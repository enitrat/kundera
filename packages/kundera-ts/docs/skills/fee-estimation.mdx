---
title: "Fee Estimation"
description: "Estimate transaction fees before sending."
---

Estimate fees for transactions via `starknet_estimateFee`. Use this to predict costs, detect reverts before sending, and set appropriate max fees.

## Quick Start

```bash
cp -r examples/skills/contract-viem src/skills/
```

Fee estimation is included in the `contract-viem` skill.

## Basic Usage

```ts
import { httpTransport } from '@kundera-sn/kundera-ts/transport';
import { signRaw, signatureToArray } from '@kundera-sn/kundera-ts/crypto';
import { createAccountInvoker } from './skills/account-invoke';
import { estimateContractFee } from './skills/contract-viem';

const transport = httpTransport('https://api.zan.top/public/starknet-sepolia');
const signTransaction = (hash) => signatureToArray(signRaw(PRIVATE_KEY, hash));
const account = createAccountInvoker({ transport, address, signTransaction });

// Estimate fee for transfer
const { result, error } = await estimateContractFee(transport, {
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

if (!error) {
  console.log('Overall fee:', result.overall_fee);
  console.log('Gas consumed:', result.gas_consumed);
  console.log('Gas price:', result.gas_price);
}
```

## How It Works

Fee estimation simulates the transaction and returns the resources that would be consumed:

```ts
// What happens under the hood:
const { result } = await estimateContractFee(transport, {
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

// Equivalent to:
import { encodeCalldata } from '@kundera-sn/kundera-ts/abi';
import { starknet_estimateFee } from '@kundera-sn/kundera-ts/rpc';

const { result: calldata } = encodeCalldata(ERC20_ABI, 'transfer', [recipient, amount]);
const feeEstimate = await starknet_estimateFee(transport, {
  type: 'INVOKE',
  sender_address: account.address,
  calldata: [...], // Encoded multicall
  version: '0x1',
  signature: [],
  nonce: await getNonce(),
});
```

## Fee Estimate Structure

```ts
interface FeeEstimate {
  overall_fee: bigint;      // Total fee in wei (ETH or STRK)
  gas_consumed: bigint;     // Gas units consumed
  gas_price: bigint;        // Price per gas unit
  data_gas_consumed: bigint; // Data availability gas (for blobs)
  data_gas_price: bigint;   // Data gas price
  unit: 'WEI' | 'FRI';      // Fee token unit
}
```

## Revert Detection

If a transaction would revert, fee estimation throws:

```ts
try {
  const { result, error } = await estimateContractFee(transport, {
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: 'transfer',
    args: [recipient, 1000000000000n], // More than balance
    account,
  });

  if (error) {
    console.error('Transaction would revert:', error.message);
  }
} catch (error) {
  // RPC error with revert reason
  console.error('Estimation failed:', error);
}
```

Use this to validate transactions before sending:

```ts
async function safeTransfer(to: string, amount: bigint) {
  const { result: fee, error } = await estimateContractFee(transport, {
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: 'transfer',
    args: [to, amount],
    account,
  });

  if (error) {
    throw new Error(`Transfer would fail: ${error.message}`);
  }

  // Safe to send with buffer
  return writeContract({
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: 'transfer',
    args: [to, amount],
    account,
    maxFee: fee.overall_fee * 120n / 100n,
  });
}
```

## Fee Buffers

Estimates are approximate. Add a buffer for safety:

```ts
const { result: fee } = await estimateContractFee(transport, { ... });

// 20% buffer (recommended)
const maxFee = fee.overall_fee * 120n / 100n;

// 10% buffer (aggressive - may fail if gas price increases)
const maxFee = fee.overall_fee * 110n / 100n;

// 50% buffer (conservative - for volatile gas prices)
const maxFee = fee.overall_fee * 150n / 100n;

const { result } = await writeContract({
  ...params,
  account,
  maxFee,
});
```

<Tip>
20% buffer is a good default. Complex transactions (DEX swaps, flash loans) may need higher buffers due to state changes between estimation and execution.
</Tip>

## Cost Calculation

Calculate transaction cost in human-readable format:

```ts
const { result: fee } = await estimateContractFee(transport, { ... });

// Convert to ETH (18 decimals)
const costEth = Number(fee.overall_fee) / 1e18;
console.log(`Estimated cost: ${costEth.toFixed(6)} ETH`);

// Or STRK depending on fee token
const costStrk = Number(fee.overall_fee) / 1e18;
console.log(`Estimated cost: ${costStrk.toFixed(6)} STRK`);
```

## Batch Fee Estimation

Estimate fees for multiple operations:

```ts
// Estimate fee for multicall (multiple calls in one transaction)
import { encodeCalldata } from '@kundera-sn/kundera-ts/abi';

const calls = [
  { contractAddress: token1, entrypoint: 'transfer', calldata: [...] },
  { contractAddress: token2, entrypoint: 'transfer', calldata: [...] },
];

// account.estimateFee handles multicall encoding
const fee = await account.estimateFee(calls);
console.log('Total fee for all operations:', fee.overall_fee);
```

## Low-Level Fee Estimation

For direct RPC access:

```ts
import { starknet_estimateFee } from '@kundera-sn/kundera-ts/rpc';

const feeEstimate = await starknet_estimateFee(transport, {
  type: 'INVOKE',
  sender_address: accountAddress,
  calldata: encodedCalldata,
  version: '0x1',
  signature: [],
  nonce: currentNonce,
  max_fee: '0x0', // Not used in estimation
});
```

## Common Patterns

### Estimate Before Approval Flow

```ts
async function estimateSwapWithApproval(amount: bigint) {
  // Check if approval needed
  const { result: allowance } = await readContract(transport, {
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: 'allowance',
    args: [myAddress, routerAddress],
  });

  const calls = [];

  if (allowance[0] < amount) {
    calls.push({
      contractAddress: tokenAddress,
      entrypoint: 'approve',
      calldata: encodeCalldata(ERC20_ABI, 'approve', [routerAddress, amount]).result,
    });
  }

  calls.push({
    contractAddress: routerAddress,
    entrypoint: 'swap',
    calldata: encodeCalldata(ROUTER_ABI, 'swap', [token, amount]).result,
  });

  const fee = await account.estimateFee(calls);
  return fee.overall_fee;
}
```

### Compare Fee Tokens

Starknet supports paying fees in ETH or STRK:

```ts
// Estimate with ETH
const ethFee = await estimateContractFee(transport, {
  ...params,
  account,
  feeToken: 'ETH',
});

// Estimate with STRK
const strkFee = await estimateContractFee(transport, {
  ...params,
  account,
  feeToken: 'STRK',
});

console.log('ETH fee:', ethFee.overall_fee);
console.log('STRK fee:', strkFee.overall_fee);
```

## Error Handling

```ts
const { result, error } = await estimateContractFee(transport, {
  abi: ERC20_ABI,
  address: tokenAddress,
  functionName: 'transfer',
  args: [recipient, amount],
  account,
});

if (error) {
  switch (error.code) {
    case 'FUNCTION_NOT_FOUND':
      console.error('Function does not exist in ABI');
      break;
    case 'ENCODE_ERROR':
      console.error('Failed to encode arguments');
      break;
    case 'ESTIMATION_FAILED':
      console.error('Transaction would revert:', error.message);
      break;
    case 'INSUFFICIENT_BALANCE':
      console.error('Not enough funds for fee');
      break;
  }
}
```

## Related

<CardGroup cols={2}>
  <Card title="Contract Write" icon="pen" href="/skills/contract-write">
    Send transactions with estimated fees.
  </Card>
  <Card title="Account Invoke" icon="bolt" href="/skills/account-invoke">
    Low-level account execution with fee estimation.
  </Card>
  <Card title="Security" icon="shield" href="/concepts/security">
    Best practices for transaction validation.
  </Card>
</CardGroup>
