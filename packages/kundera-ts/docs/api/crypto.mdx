---
title: Crypto API
description: Hashing, signatures, and field arithmetic for Starknet.
---

Cryptographic primitives for Starknet including hash functions, ECDSA signatures, and field operations.

## Imports

```typescript
// Native (FFI-backed, preferred for servers)
import * as crypto from 'kundera-sn/native';
```

```typescript
// WASM (browser/portable)
import * as crypto from 'kundera-sn/wasm';
await crypto.loadWasmCrypto();
```

You can also import named helpers from any entrypoint:

```typescript
import { pedersenHash, sign, type Signature } from 'kundera-sn/native';
```

## Backend Selection

Kundera exposes explicit crypto entrypoints:

- `kundera-sn/native` for FFI-backed crypto
- `kundera-sn/wasm` for portable/browser crypto (call `loadWasmCrypto` once)
- `kundera-sn/crypto` for auto-selection if you want a single import

All entrypoints share the same API surface.

### isNativeAvailable

Check if native crypto is available (Bun FFI or Node ffi-napi).

```typescript
function isNativeAvailable(): boolean
```

### isWasmAvailable

Check if WASM crypto can be loaded.

```typescript
function isWasmAvailable(): boolean
```

### isWasmLoaded

Check if WASM crypto is currently loaded.

```typescript
function isWasmLoaded(): boolean
```

### loadWasmCrypto

Load the WASM crypto backend (required for browsers).

```typescript
async function loadWasmCrypto(): Promise<void>
```

```typescript
// Browser initialization
import * as crypto from 'kundera-sn/crypto';

if (!crypto.isNativeAvailable()) {
  await crypto.loadWasmCrypto();
}

// Now crypto functions work
const hash = crypto.pedersenHash(a, b);
```

<Tip>
Native crypto is preferred for performance. For browsers, use the `kundera-sn/wasm` entrypoint (or `kundera-sn/crypto` if you want auto-selection).
</Tip>

## Hash Functions

### pedersenHash

Pedersen hash of two field elements.

```typescript
function pedersenHash(a: Felt252Type, b: Felt252Type): Felt252Type
```

```typescript
const hash = pedersenHash(
  Felt252(123n),
  Felt252(456n)
);
```

Used for: Transaction hashes, contract addresses, Merkle trees.

### poseidonHash

Poseidon hash of two field elements.

```typescript
function poseidonHash(a: Felt252Type, b: Felt252Type): Felt252Type
```

```typescript
const hash = poseidonHash(
  Felt252(123n),
  Felt252(456n)
);
```

Used for: Newer contracts, more efficient than Pedersen.

### poseidonHashMany

Poseidon hash of multiple field elements.

```typescript
function poseidonHashMany(inputs: Felt252Type[]): Felt252Type
```

```typescript
const hash = poseidonHashMany([
  Felt252(1n),
  Felt252(2n),
  Felt252(3n),
]);
```

### snKeccak

Starknet Keccak-256 (truncated to 250 bits).

```typescript
function snKeccak(data: Uint8Array | string): Felt252Type
```

```typescript
const selector = snKeccak('transfer');
```

Used for: Function and event selectors.

## ECDSA Signatures

Starknet uses ECDSA over the STARK curve (not secp256k1).

### sign

Sign a message hash with a private key.

```typescript
function sign(
  privateKey: Felt252Type,
  messageHash: Felt252Type
): Signature
```

```typescript
const signature = sign(privateKey, messageHash);
// { r: Felt252Type, s: Felt252Type }
```

### signRaw

Convenience wrapper that accepts `Felt252Input` values.

```typescript
function signRaw(
  privateKey: Felt252Input,
  hash: Felt252Input
): Signature
```

```typescript
const signature = signRaw('0x123', '0xabc');
```

## SNIP-12 Typed Data

[SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) is Starknet's standard for signing typed structured data (similar to Ethereum's EIP-712). It enables users to sign human-readable data instead of opaque hashes.

### Why SNIP-12?

| Without SNIP-12 | With SNIP-12 |
|-----------------|--------------|
| User sees: `Sign hash 0x7f3a...` | User sees: `Transfer 100 STRK to alice.stark` |
| Can't verify what they're signing | Clear, readable transaction details |
| Phishing risk | Wallet shows structured data |

### TypedData Structure

```typescript
interface TypedData {
  types: Record<string, TypedDataType[]>;
  primaryType: string;
  domain: StarkNetDomain;
  message: Record<string, unknown>;
}

interface StarkNetDomain {
  name: string;
  version: string;
  chainId: string;
  revision?: string;
}
```

### hashTypedData

Compute the SNIP-12 typed data hash for signing.

```typescript
function hashTypedData(
  typedData: TypedData,
  accountAddress: string
): Felt252Type
```

```typescript
const typedData: TypedData = {
  types: {
    StarkNetDomain: [
      { name: 'name', type: 'felt' },
      { name: 'version', type: 'felt' },
      { name: 'chainId', type: 'felt' },
    ],
    Transfer: [
      { name: 'recipient', type: 'felt' },
      { name: 'amount', type: 'u256' },
    ],
  },
  primaryType: 'Transfer',
  domain: {
    name: 'MyDApp',
    version: '1',
    chainId: '0x534e5f4d41494e', // SN_MAIN
  },
  message: {
    recipient: '0x123...',
    amount: { low: '1000000000000000000', high: '0' },
  },
};

const hash = hashTypedData(typedData, accountAddress);
```

### signTypedData

Hash and sign typed data in one step.

```typescript
function signTypedData(
  privateKey: Felt252Input,
  typedData: TypedData,
  accountAddress: string
): Signature
```

```typescript
const signature = signTypedData(privateKey, typedData, accountAddress);
// { r: Felt252Type, s: Felt252Type }
```

<Note>
For user-facing applications, use wallet extensions (Argent, Braavos) which display SNIP-12 data to users for review before signing. Never ask users to sign raw hashes.
</Note>

### verify

Verify a signature.

```typescript
function verify(
  publicKey: Felt252Type,
  messageHash: Felt252Type,
  signature: Signature
): boolean
```

```typescript
const isValid = verify(publicKey, messageHash, signature);
```

### getPublicKey

Derive public key from private key.

```typescript
function getPublicKey(privateKey: Felt252Type): Felt252Type
```

```typescript
const publicKey = getPublicKey(privateKey);
```

### recover

Recover public key from signature.

```typescript
function recover(
  messageHash: Felt252Type,
  r: Felt252Type,
  s: Felt252Type,
  v: number
): Felt252Type
```

## Field Arithmetic

Operations over the Stark field.

### feltAdd

Field addition.

```typescript
function feltAdd(a: Felt252Type, b: Felt252Type): Felt252Type
```

### feltSub

Field subtraction.

```typescript
function feltSub(a: Felt252Type, b: Felt252Type): Felt252Type
```

### feltMul

Field multiplication.

```typescript
function feltMul(a: Felt252Type, b: Felt252Type): Felt252Type
```

### feltDiv

Field division.

```typescript
function feltDiv(a: Felt252Type, b: Felt252Type): Felt252Type
```

### feltNeg

Field negation.

```typescript
function feltNeg(a: Felt252Type): Felt252Type
```

### feltInverse

Multiplicative inverse.

```typescript
function feltInverse(a: Felt252Type): Felt252Type
```

### feltPow

Field exponentiation.

```typescript
function feltPow(base: Felt252Type, exp: Felt252Type): Felt252Type
```

### feltSqrt

Square root (if exists).

```typescript
function feltSqrt(a: Felt252Type): Felt252Type | null
```

## Types

### Signature

ECDSA signature pair.

```typescript
interface Signature {
  r: Felt252Type;
  s: Felt252Type;
}
```

## Example: Sign and Verify

```typescript
import {
  loadWasmCrypto,
  isNativeAvailable,
  sign,
  verify,
  getPublicKey,
  pedersenHash,
} from 'kundera-sn/crypto';
import { Felt252 } from 'kundera-sn';

// Initialize crypto
if (!isNativeAvailable()) {
  await loadWasmCrypto();
}

// Create keys
const privateKey = Felt252('0x_YOUR_PRIVATE_KEY');
const publicKey = getPublicKey(privateKey);

// Hash a message
const messageHash = pedersenHash(
  Felt252(123n),
  Felt252(456n)
);

// Sign
const signature = sign(privateKey, messageHash);

// Verify
const isValid = verify(publicKey, messageHash, signature);
console.log('Valid:', isValid); // true
```

<Warning>
## Private Key Security

Never expose private keys in client-side code. Use wallet extensions for user-facing applications.
</Warning>

## Related

<CardGroup cols={2}>
  <Card title="Security" icon="shield" href="/concepts/security">
    Cryptographic best practices.
  </Card>
  <Card title="SNIP-12 Specification" icon="file-lines" href="https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md">
    Official typed data signing standard.
  </Card>
</CardGroup>
