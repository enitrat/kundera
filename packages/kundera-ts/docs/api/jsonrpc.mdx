---
title: JSON-RPC API
description: Tree-shakeable Starknet JSON-RPC request builders and wire types.
---

<Info>
Source: [jsonrpc](https://github.com/enitrat/kundera/tree/main/packages/kundera-ts/src/jsonrpc)
</Info>

# JSON-RPC API

The JSON-RPC module provides request builders for all 37 Starknet JSON-RPC methods and re-exports the wire types that describe their parameters and return values.

## Request Builders

Every Starknet JSON-RPC method has a corresponding request builder function exported through the `Rpc` namespace. Builders construct `{ method, params }` objects that you pass to a provider's `request()` method.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';

const provider = new HttpProvider({
  url: 'https://api.zan.top/public/starknet-sepolia'
});

// Build a request, then send it
const request = Rpc.GetNonceRequest({ block_number: 123 }, '0xabc...');
// { method: 'starknet_getNonce', params: [{ block_number: 123 }, '0xabc...'] }

const nonce = await provider.request(request);
```

### Naming Convention

Builders follow the pattern `Rpc.MethodNameRequest(params)`. The method name matches the JSON-RPC method with the `starknet_` prefix stripped and PascalCased.

| JSON-RPC Method | Builder |
|----------------|---------|
| `starknet_blockNumber` | `Rpc.BlockNumberRequest()` |
| `starknet_getNonce` | `Rpc.GetNonceRequest(blockId, address)` |
| `starknet_getBlockWithTxHashes` | `Rpc.GetBlockWithTxHashesRequest(blockId)` |
| `starknet_call` | `Rpc.CallRequest(functionCall, blockId)` |
| `starknet_estimateFee` | `Rpc.EstimateFeeRequest(txns, flags, blockId)` |

### One File Per Method

Each builder lives in its own file under `jsonrpc/starknet/`. This means bundlers can tree-shake unused methods — if you only call `Rpc.BlockNumberRequest`, the other 36 builders are excluded from your bundle.

## Wire Types

The module re-exports all Starknet JSON-RPC wire types from `jsonrpc/types.ts`. These are the raw shapes defined by the Starknet JSON-RPC specification — they use hex strings for felts, nested objects for blocks and transactions, and string enums for statuses.

```typescript
import type {
  BlockWithTxHashes,
  TxnWithHash,
  FeeEstimate,
  BlockId,
  FunctionCall,
  TransactionStatus
} from '@kundera-sn/kundera-ts/jsonrpc';
```

Wire types are stable protocol definitions. They change only when the Starknet specification changes.

## BlockId

Many methods accept a `BlockId` parameter to specify which block to query. Valid values:

```typescript
type BlockId =
  | 'latest'                        // Most recent accepted block
  | 'pending'                       // Pending block (not yet accepted)
  | { block_number: number }        // Specific block by number
  | { block_hash: string }          // Specific block by hash
```

## Method Reference

### Read Methods

Query chain state without creating transactions.

```typescript
// Current block number
const blockNum = await provider.request(Rpc.BlockNumberRequest());

// Block hash and number together
const hashAndNum = await provider.request(Rpc.BlockHashAndNumberRequest());

// Chain ID
const chainId = await provider.request(Rpc.ChainIdRequest());

// Spec version
const specVersion = await provider.request(Rpc.SpecVersionRequest());

// Sync status
const syncStatus = await provider.request(Rpc.SyncingRequest());
```

### Block Methods

```typescript
// Block with transaction hashes only (lighter)
const block = await provider.request(
  Rpc.GetBlockWithTxHashesRequest({ block_number: 12345 })
);

// Block with full transactions
const blockFull = await provider.request(
  Rpc.GetBlockWithTxsRequest('latest')
);

// Block with transactions and receipts
const blockReceipts = await provider.request(
  Rpc.GetBlockWithReceiptsRequest('latest')
);

// Transaction count in a block
const count = await provider.request(
  Rpc.GetBlockTransactionCountRequest({ block_number: 12345 })
);

// State update for a block
const stateUpdate = await provider.request(
  Rpc.GetStateUpdateRequest('latest')
);
```

### Contract Methods

```typescript
// Call a contract (read-only)
const result = await provider.request(
  Rpc.CallRequest(
    {
      contract_address: '0x...',
      entry_point_selector: '0x...',
      calldata: ['0x1', '0x2']
    },
    'latest'
  )
);

// Get contract nonce
const nonce = await provider.request(
  Rpc.GetNonceRequest('latest', '0x...')
);

// Get storage value
const value = await provider.request(
  Rpc.GetStorageAtRequest('0x...', '0x0', 'latest')
);

// Get class hash at address
const classHash = await provider.request(
  Rpc.GetClassHashAtRequest('latest', '0x...')
);

// Get contract class
const contractClass = await provider.request(
  Rpc.GetClassRequest('latest', '0x...')
);

// Get class at address
const classAt = await provider.request(
  Rpc.GetClassAtRequest('latest', '0x...')
);
```

### Transaction Methods

```typescript
// Get transaction by hash
const tx = await provider.request(
  Rpc.GetTransactionByHashRequest('0x...')
);

// Get transaction by block and index
const tx2 = await provider.request(
  Rpc.GetTransactionByBlockIdAndIndexRequest('latest', 0)
);

// Get receipt
const receipt = await provider.request(
  Rpc.GetTransactionReceiptRequest('0x...')
);

// Get status
const status = await provider.request(
  Rpc.GetTransactionStatusRequest('0x...')
);

// Get message status
const msgStatus = await provider.request(
  Rpc.GetMessagesStatusRequest('0x...')
);
```

### Submit Methods

```typescript
// Submit invoke transaction
const invokeResult = await provider.request(
  Rpc.AddInvokeTransactionRequest(invokeTx)
);
// invokeResult.transaction_hash: string

// Submit declare transaction
const declareResult = await provider.request(
  Rpc.AddDeclareTransactionRequest(declareTx)
);

// Submit deploy account transaction
const deployResult = await provider.request(
  Rpc.AddDeployAccountTransactionRequest(deployAccountTx)
);
```

### Fee Estimation

```typescript
const estimates = await provider.request(
  Rpc.EstimateFeeRequest(
    [tx],           // transactions
    [],             // simulation flags
    'latest'        // block ID
  )
);

const msgFee = await provider.request(
  Rpc.EstimateMessageFeeRequest(msgFromL1, 'latest')
);
```

### Event Methods

```typescript
const { events, continuation_token } = await provider.request(
  Rpc.GetEventsRequest({
    filter: {
      from_block: { block_number: 100000 },
      to_block: 'latest',
      address: '0x...',
      keys: [['0x...']],
      chunk_size: 100
    }
  })
);
```

### Trace Methods

```typescript
// Single transaction trace
const trace = await provider.request(
  Rpc.TraceTransactionRequest('0x...')
);

// All traces in a block
const blockTraces = await provider.request(
  Rpc.TraceBlockTransactionsRequest('latest')
);

// Simulate transactions
const simulations = await provider.request(
  Rpc.SimulateTransactionsRequest('latest', [tx], [])
);
```

### Proof Methods

```typescript
const proof = await provider.request(
  Rpc.GetStorageProofRequest('latest', ['0x...'], ['0x...'], ['0x...'])
);
```

## Complete Method List

| Category | Methods |
|----------|---------|
| **Read** | `blockNumber`, `blockHashAndNumber`, `chainId`, `specVersion`, `syncing` |
| **Block** | `getBlockWithTxHashes`, `getBlockWithTxs`, `getBlockWithReceipts`, `getBlockTransactionCount`, `getStateUpdate` |
| **Transaction** | `getTransactionByHash`, `getTransactionByBlockIdAndIndex`, `getTransactionReceipt`, `getTransactionStatus`, `getMessagesStatus` |
| **Submit** | `addInvokeTransaction`, `addDeclareTransaction`, `addDeployAccountTransaction` |
| **Contract** | `call`, `getClass`, `getClassAt`, `getClassHashAt`, `getStorageAt`, `getNonce` |
| **Fee** | `estimateFee`, `estimateMessageFee` |
| **Events** | `getEvents` |
| **Trace** | `traceTransaction`, `traceBlockTransactions`, `simulateTransactions` |
| **Proof** | `getStorageProof` |
| **Subscribe** | `subscribeNewHeads`, `subscribeEvents`, `subscribeTransactionStatus`, `subscribeNewTransactions`, `subscribeNewTransactionReceipts`, `unsubscribe` |

## Error Handling

All methods can throw JSON-RPC errors. Use `isJsonRpcError` from the transport module to check.

```typescript
import { isJsonRpcError } from '@kundera-sn/kundera-ts/transport';

try {
  const result = await provider.request(Rpc.CallRequest(params, 'latest'));
} catch (error) {
  if (isJsonRpcError(error)) {
    // error.code and error.message available
  }
}
```

## Related

<CardGroup cols={2}>
  <Card title="Provider Guide" icon="plug" href="/guides/provider/providers">
    Provider patterns and recipes.
  </Card>
  <Card title="Provider API" icon="plug" href="/api/provider">
    Provider interface and configuration.
  </Card>
  <Card title="Domain Primitives" icon="cube" href="/primitives/domain-primitives">
    Convert wire types to rich domain types.
  </Card>
  <Card title="Architecture" icon="sitemap" href="/overview/architecture">
    How JSON-RPC fits in the stack.
  </Card>
</CardGroup>
