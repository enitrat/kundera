---
title: Provider Guide
description: Patterns and best practices for HTTP and WebSocket providers.
---

# Provider Guide

Providers are the primary interface between your application and a Starknet node. They wrap a transport with operational concerns — retries, timeouts, event emission — and expose a single `request()` method for all JSON-RPC calls.

## Setting Up

The simplest setup is an `HttpProvider` with the `Rpc` namespace for building requests.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';

const provider = new HttpProvider({
  url: 'https://api.zan.top/public/starknet-sepolia',
  timeout: 30_000,
  retry: 2,
  retryDelay: 250
});

const blockNumber = await provider.request(Rpc.BlockNumberRequest());
```

The provider doesn't have typed convenience methods like `provider.getBlockNumber()`. There is one method — `request()` — and you pass it a request object. This keeps the provider thin and the API surface predictable.

## Typed Providers

By default, `provider.request()` returns `Promise<unknown>`. If you want the TypeScript compiler to infer return types from your method strings, cast the provider to `TypedProvider<StarknetRpcSchema>`.

```typescript
import { HttpProvider } from '@kundera-sn/kundera-ts/provider';
import type { TypedProvider, StarknetRpcSchema } from '@kundera-sn/kundera-ts/provider';

const provider = new HttpProvider({
  url: 'https://api.zan.top/public/starknet-sepolia'
}) as TypedProvider<StarknetRpcSchema>;

// TypeScript infers return type from the literal method string
const chainId = await provider.request({
  method: 'starknet_chainId',
  params: []
});
// chainId: string ✓

const block = await provider.request({
  method: 'starknet_getBlockWithTxHashes',
  params: [{ block_number: 12345 }]
});
// block: BlockWithTxHashes ✓
```

This is a compile-time overlay. The runtime behavior is identical — the cast adds zero cost. See the [Architecture](/overview/architecture) page for the full explanation of type honesty and the schema system.

## HTTP Provider Patterns

### Parallel Requests

Independent requests should always run concurrently.

```typescript
const [balance, nonce, classHash] = await Promise.all([
  provider.request(Rpc.GetStorageAtRequest(address, '0x0', 'latest')),
  provider.request(Rpc.GetNonceRequest('latest', address)),
  provider.request(Rpc.GetClassHashAtRequest('latest', address))
]);
```

### Request-Level Overrides

Every request accepts optional overrides for timeout and retry behavior, independent of the provider defaults.

```typescript
// Long-running request with extended timeout
const block = await provider.request(
  Rpc.GetBlockWithReceiptsRequest('latest'),
  { timeout: 60_000 }
);

// Critical request with aggressive retries
const result = await provider.request(
  Rpc.EstimateFeeRequest([tx], [], 'latest'),
  { retryCount: 5, retryDelay: 1000 }
);
```

## WebSocket Provider

For real-time data, use `WebSocketProvider`. It supports the same `request()` interface as `HttpProvider`, plus async generator subscriptions.

### Setup and Connection

```typescript
import { WebSocketProvider } from '@kundera-sn/kundera-ts/provider';

const ws = new WebSocketProvider({
  url: 'wss://starknet-sepolia.example.com',
  reconnect: true,
  reconnectDelay: 1000
});

await ws.connect();
```

### Subscribing to New Blocks

```typescript
for await (const head of ws.events.newHeads()) {
  // head is a NewHead wire type
  console.log('New block:', head.block_number);
  await processBlock(head);
}
```

### Subscribing to Contract Events

```typescript
for await (const event of ws.events.events({
  from_address: contractAddress,
  keys: [[transferEventKey]],
  block_id: 'latest'
})) {
  console.log('Event data:', event.data);
}
```

### Transaction Status Tracking

```typescript
for await (const status of ws.events.transactionStatus(txHash)) {
  if (status.finality_status === 'ACCEPTED_ON_L2') {
    return 'confirmed';
  }
  if (status.finality_status === 'REJECTED') {
    return 'rejected';
  }
}
```

### Connection Lifecycle

```typescript
ws.on('connect', () => {
  console.log('Connected');
});

ws.on('disconnect', (error) => {
  console.log('Disconnected:', error?.message);
});

await ws.connect();

// ... use provider ...

ws.disconnect();
```

## Converting Wire Types to Domain Types

Providers return wire types — the raw JSON-RPC response shapes with hex strings. If you need rich types with `Felt252`, `ContractAddress`, etc., use the domain primitive codecs explicitly.

```typescript
import { Rpc } from '@kundera-sn/kundera-ts/jsonrpc';
import { blockWithTxHashesFromRpc } from '@kundera-sn/kundera-ts/Block';
import { transactionFromRpc } from '@kundera-sn/kundera-ts/Transaction';

// Wire type from the node
const wire = await provider.request(
  Rpc.GetBlockWithTxHashesRequest('latest')
);

// Convert when you need rich types
const block = blockWithTxHashesFromRpc(wire);
// block.blockHeader.parentHash: Felt252Type
// block.blockHeader.sequencerAddress: ContractAddressType
```

This conversion is always opt-in. Many use cases — forwarding data to a frontend, storing raw responses, piping to another RPC call — don't need domain types at all.

## Error Handling

JSON-RPC errors are thrown as **plain objects** `{ code: number, message: string }`, not `Error` instances. Use a type guard or check for the `code` property:

```typescript
try {
  const receipt = await provider.request(
    Rpc.GetTransactionReceiptRequest(txHash)
  );
} catch (error) {
  // RPC errors are plain objects, not Error instances
  if (typeof error === 'object' && error !== null && 'code' in error) {
    const rpcError = error as { code: number; message: string };
    if (rpcError.code === 25) {
      // Transaction not found — might still be pending
      return null;
    }
  }
  throw error;
}
```

Common error codes: `-32601` (method not found), `-32602` (invalid params), `20` (contract not found), `21` (block not found), `25` (transaction not found), `29` (contract execution error).

## Recipes

### Get Account State

```typescript
async function getAccountState(provider, address: string) {
  const [nonce, classHash] = await Promise.all([
    provider.request(Rpc.GetNonceRequest('latest', address)),
    provider.request(Rpc.GetClassHashAtRequest('latest', address))
      .catch(() => null)
  ]);

  return { address, nonce, classHash, isDeployed: classHash !== null };
}
```

### Wait for Transaction (Polling)

```typescript
async function waitForTransaction(provider, txHash: string) {
  const timeout = 120_000;
  const poll = 3_000;
  const start = Date.now();

  while (Date.now() - start < timeout) {
    try {
      const status = await provider.request(
        Rpc.GetTransactionStatusRequest(txHash)
      );
      if (status.finality_status === 'ACCEPTED_ON_L2' ||
          status.finality_status === 'ACCEPTED_ON_L1') {
        return provider.request(Rpc.GetTransactionReceiptRequest(txHash));
      }
      if (status.finality_status === 'REJECTED') {
        throw new Error('Transaction rejected');
      }
    } catch {
      // Not yet visible, keep polling
    }
    await new Promise(r => setTimeout(r, poll));
  }

  throw new Error('Transaction confirmation timeout');
}
```

### Paginate Events

```typescript
async function getAllEvents(provider, filter) {
  const events = [];
  let token;

  do {
    const response = await provider.request(
      Rpc.GetEventsRequest({
        filter: { ...filter, chunk_size: 100, continuation_token: token }
      })
    );
    events.push(...response.events);
    token = response.continuation_token;
  } while (token);

  return events;
}
```

### Multi-Provider Fallback

```typescript
async function requestWithFallback(providers, args) {
  for (const provider of providers) {
    try {
      return await provider.request(args);
    } catch {
      continue;
    }
  }
  throw new Error('All providers failed');
}

const result = await requestWithFallback(
  [
    new HttpProvider({ url: 'https://primary.rpc.com' }),
    new HttpProvider({ url: 'https://backup.rpc.com' })
  ],
  Rpc.BlockNumberRequest()
);
```

## Related

<CardGroup cols={2}>
  <Card title="Architecture" icon="sitemap" href="/overview/architecture">
    How providers fit in the layered stack.
  </Card>
  <Card title="Provider API" icon="plug" href="/api/provider">
    Complete provider API reference.
  </Card>
  <Card title="JSON-RPC Reference" icon="code" href="/api/jsonrpc">
    Request builders and method list.
  </Card>
  <Card title="Domain Primitives" icon="cube" href="/primitives/domain-primitives">
    fromRpc/toRpc codec reference.
  </Card>
</CardGroup>
